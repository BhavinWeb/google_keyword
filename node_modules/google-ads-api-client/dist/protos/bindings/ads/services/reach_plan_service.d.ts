import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { UserInterestInfo } from "../common/criteria";
import { DateRange } from "../common/dates";
import { FrequencyCapTimeUnitEnum_FrequencyCapTimeUnit } from "../enums/frequency_cap_time_unit";
import { ReachPlanAdLengthEnum_ReachPlanAdLength } from "../enums/reach_plan_ad_length";
import { ReachPlanNetworkEnum_ReachPlanNetwork } from "../enums/reach_plan_network";
import { DeviceInfo } from "../common/criteria";
import { GenderInfo } from "../common/criteria";
import { ReachPlanAgeRangeEnum_ReachPlanAgeRange } from "../enums/reach_plan_age_range";
/**
 * Request message for [ReachPlanService.ListPlannableLocations][google.ads.googleads.v11.services.ReachPlanService.ListPlannableLocations].
 *
 * @generated from protobuf message google.ads.googleads.v11.services.ListPlannableLocationsRequest
 */
export interface ListPlannableLocationsRequest {
}
/**
 * The list of plannable locations.
 *
 * @generated from protobuf message google.ads.googleads.v11.services.ListPlannableLocationsResponse
 */
export interface ListPlannableLocationsResponse {
    /**
     * The list of locations available for planning.
     * See
     * https://developers.google.com/google-ads/api/reference/data/geotargets
     * for sample locations.
     *
     * @generated from protobuf field: repeated google.ads.googleads.v11.services.PlannableLocation plannable_locations = 1;
     */
    plannableLocations: PlannableLocation[];
}
/**
 * A plannable location: country, metro region, province, etc.
 *
 * @generated from protobuf message google.ads.googleads.v11.services.PlannableLocation
 */
export interface PlannableLocation {
    /**
     * The location identifier.
     *
     * @generated from protobuf field: optional string id = 4;
     */
    id?: string;
    /**
     * The unique location name in English.
     *
     * @generated from protobuf field: optional string name = 5;
     */
    name?: string;
    /**
     * The parent country (not present if location is a country).
     * If present, will always be a GeoTargetConstant ID. Additional information
     * such as country name is provided by
     * [ReachPlanService.ListPlannableLocations][google.ads.googleads.v11.services.ReachPlanService.ListPlannableLocations] or
     * [GoogleAdsService.Search/SearchStream][].
     *
     * @generated from protobuf field: optional int64 parent_country_id = 6;
     */
    parentCountryId?: bigint;
    /**
     * The ISO-3166-1 alpha-2 country code that is associated with the location.
     *
     * @generated from protobuf field: optional string country_code = 7;
     */
    countryCode?: string;
    /**
     * The location's type. Location types correspond to target_type returned by
     * searching location type in [GoogleAdsService.Search/SearchStream][].
     *
     * @generated from protobuf field: optional string location_type = 8;
     */
    locationType?: string;
}
/**
 * Request to list available products in a given location.
 *
 * @generated from protobuf message google.ads.googleads.v11.services.ListPlannableProductsRequest
 */
export interface ListPlannableProductsRequest {
    /**
     * Required. The ID of the selected location for planning. To list the available
     * plannable location IDs use [ReachPlanService.ListPlannableLocations][google.ads.googleads.v11.services.ReachPlanService.ListPlannableLocations].
     *
     * @generated from protobuf field: string plannable_location_id = 2;
     */
    plannableLocationId: string;
}
/**
 * A response with all available products.
 *
 * @generated from protobuf message google.ads.googleads.v11.services.ListPlannableProductsResponse
 */
export interface ListPlannableProductsResponse {
    /**
     * The list of products available for planning and related targeting metadata.
     *
     * @generated from protobuf field: repeated google.ads.googleads.v11.services.ProductMetadata product_metadata = 1;
     */
    productMetadata: ProductMetadata[];
}
/**
 * The metadata associated with an available plannable product.
 *
 * @generated from protobuf message google.ads.googleads.v11.services.ProductMetadata
 */
export interface ProductMetadata {
    /**
     * The code associated with the ad product (for example: BUMPER,
     * TRUEVIEW_IN_STREAM).
     * To list the available plannable product codes use
     * [ReachPlanService.ListPlannableProducts][google.ads.googleads.v11.services.ReachPlanService.ListPlannableProducts].
     *
     * @generated from protobuf field: optional string plannable_product_code = 4;
     */
    plannableProductCode?: string;
    /**
     * The name associated with the ad product.
     *
     * @generated from protobuf field: string plannable_product_name = 3;
     */
    plannableProductName: string;
    /**
     * The allowed plannable targeting for this product.
     *
     * @generated from protobuf field: google.ads.googleads.v11.services.PlannableTargeting plannable_targeting = 2;
     */
    plannableTargeting?: PlannableTargeting;
}
/**
 * The targeting for which traffic metrics will be reported.
 *
 * @generated from protobuf message google.ads.googleads.v11.services.PlannableTargeting
 */
export interface PlannableTargeting {
    /**
     * Allowed plannable age ranges for the product for which metrics will be
     * reported. Actual targeting is computed by mapping this age range onto
     * standard Google common.AgeRangeInfo values.
     *
     * @generated from protobuf field: repeated google.ads.googleads.v11.enums.ReachPlanAgeRangeEnum.ReachPlanAgeRange age_ranges = 1;
     */
    ageRanges: ReachPlanAgeRangeEnum_ReachPlanAgeRange[];
    /**
     * Targetable genders for the ad product.
     *
     * @generated from protobuf field: repeated google.ads.googleads.v11.common.GenderInfo genders = 2;
     */
    genders: GenderInfo[];
    /**
     * Targetable devices for the ad product.
     * TABLET device targeting is automatically applied to reported metrics
     * when MOBILE targeting is selected for CPM_MASTHEAD,
     * GOOGLE_PREFERRED_BUMPER, and GOOGLE_PREFERRED_SHORT products.
     *
     * @generated from protobuf field: repeated google.ads.googleads.v11.common.DeviceInfo devices = 3;
     */
    devices: DeviceInfo[];
    /**
     * Targetable networks for the ad product.
     *
     * @generated from protobuf field: repeated google.ads.googleads.v11.enums.ReachPlanNetworkEnum.ReachPlanNetwork networks = 4;
     */
    networks: ReachPlanNetworkEnum_ReachPlanNetwork[];
    /**
     * Targetable YouTube Select Lineups for the ad product.
     *
     * @generated from protobuf field: repeated google.ads.googleads.v11.services.YouTubeSelectLineUp youtube_select_lineups = 5;
     */
    youtubeSelectLineups: YouTubeSelectLineUp[];
}
/**
 * Request message for [ReachPlanService.GenerateProductMixIdeas][google.ads.googleads.v11.services.ReachPlanService.GenerateProductMixIdeas].
 *
 * @generated from protobuf message google.ads.googleads.v11.services.GenerateProductMixIdeasRequest
 */
export interface GenerateProductMixIdeasRequest {
    /**
     * Required. The ID of the customer.
     *
     * @generated from protobuf field: string customer_id = 1;
     */
    customerId: string;
    /**
     * Required. The ID of the location, this is one of the IDs returned by
     * [ReachPlanService.ListPlannableLocations][google.ads.googleads.v11.services.ReachPlanService.ListPlannableLocations].
     *
     * @generated from protobuf field: string plannable_location_id = 6;
     */
    plannableLocationId: string;
    /**
     * Required. Currency code.
     * Three-character ISO 4217 currency code.
     *
     * @generated from protobuf field: string currency_code = 7;
     */
    currencyCode: string;
    /**
     * Required. Total budget.
     * Amount in micros. One million is equivalent to one unit.
     *
     * @generated from protobuf field: int64 budget_micros = 8;
     */
    budgetMicros: bigint;
    /**
     * The preferences of the suggested product mix.
     * An unset preference is interpreted as all possible values are allowed,
     * unless explicitly specified.
     *
     * @generated from protobuf field: google.ads.googleads.v11.services.Preferences preferences = 5;
     */
    preferences?: Preferences;
}
/**
 * Set of preferences about the planned mix.
 *
 * @generated from protobuf message google.ads.googleads.v11.services.Preferences
 */
export interface Preferences {
    /**
     * True if ad skippable.
     * If not set, default is any value.
     *
     * @generated from protobuf field: optional bool is_skippable = 6;
     */
    isSkippable?: boolean;
    /**
     * True if ad start with sound.
     * If not set, default is any value.
     *
     * @generated from protobuf field: optional bool starts_with_sound = 7;
     */
    startsWithSound?: boolean;
    /**
     * The length of the ad.
     * If not set, default is any value.
     *
     * @generated from protobuf field: google.ads.googleads.v11.enums.ReachPlanAdLengthEnum.ReachPlanAdLength ad_length = 3;
     */
    adLength: ReachPlanAdLengthEnum_ReachPlanAdLength;
    /**
     * True if ad will only show on the top content.
     * If not set, default is false.
     *
     * @generated from protobuf field: optional bool top_content_only = 8;
     */
    topContentOnly?: boolean;
    /**
     * True if the price is guaranteed. The cost of serving the ad is agreed
     * upfront and not subject to an auction.
     * If not set, default is any value.
     *
     * @generated from protobuf field: optional bool has_guaranteed_price = 9;
     */
    hasGuaranteedPrice?: boolean;
}
/**
 * The suggested product mix.
 *
 * @generated from protobuf message google.ads.googleads.v11.services.GenerateProductMixIdeasResponse
 */
export interface GenerateProductMixIdeasResponse {
    /**
     * A list of products (ad formats) and the associated budget allocation idea.
     *
     * @generated from protobuf field: repeated google.ads.googleads.v11.services.ProductAllocation product_allocation = 1;
     */
    productAllocation: ProductAllocation[];
}
/**
 * An allocation of a part of the budget on a given product.
 *
 * @generated from protobuf message google.ads.googleads.v11.services.ProductAllocation
 */
export interface ProductAllocation {
    /**
     * Selected product for planning. The product codes returned are within the
     * set of the ones returned by ListPlannableProducts when using the same
     * location ID.
     *
     * @generated from protobuf field: optional string plannable_product_code = 3;
     */
    plannableProductCode?: string;
    /**
     * The value to be allocated for the suggested product in requested currency.
     * Amount in micros. One million is equivalent to one unit.
     *
     * @generated from protobuf field: optional int64 budget_micros = 4;
     */
    budgetMicros?: bigint;
}
/**
 * Request message for [ReachPlanService.GenerateReachForecast][google.ads.googleads.v11.services.ReachPlanService.GenerateReachForecast].
 *
 * @generated from protobuf message google.ads.googleads.v11.services.GenerateReachForecastRequest
 */
export interface GenerateReachForecastRequest {
    /**
     * Required. The ID of the customer.
     *
     * @generated from protobuf field: string customer_id = 1;
     */
    customerId: string;
    /**
     * The currency code.
     * Three-character ISO 4217 currency code.
     *
     * @generated from protobuf field: optional string currency_code = 9;
     */
    currencyCode?: string;
    /**
     * Required. Campaign duration.
     *
     * @generated from protobuf field: google.ads.googleads.v11.services.CampaignDuration campaign_duration = 3;
     */
    campaignDuration?: CampaignDuration;
    /**
     * Chosen cookie frequency cap to be applied to each planned product.
     * This is equivalent to the frequency cap exposed in Google Ads when creating
     * a campaign, it represents the maximum number of times an ad can be shown to
     * the same user.
     * If not specified, no cap is applied.
     *
     * This field is deprecated in v4 and will eventually be removed.
     * Use cookie_frequency_cap_setting instead.
     *
     * @generated from protobuf field: optional int32 cookie_frequency_cap = 10;
     */
    cookieFrequencyCap?: number;
    /**
     * Chosen cookie frequency cap to be applied to each planned product.
     * This is equivalent to the frequency cap exposed in Google Ads when creating
     * a campaign, it represents the maximum number of times an ad can be shown to
     * the same user during a specified time interval.
     * If not specified, a default of 0 (no cap) is applied.
     *
     * This field replaces the deprecated cookie_frequency_cap field.
     *
     * @generated from protobuf field: google.ads.googleads.v11.services.FrequencyCap cookie_frequency_cap_setting = 8;
     */
    cookieFrequencyCapSetting?: FrequencyCap;
    /**
     * Chosen minimum effective frequency (the number of times a person was
     * exposed to the ad) for the reported reach metrics [1-10].
     * This won't affect the targeting, but just the reporting.
     * If not specified, a default of 1 is applied.
     *
     * This field cannot be combined with the effective_frequency_limit field.
     *
     * @generated from protobuf field: optional int32 min_effective_frequency = 11;
     */
    minEffectiveFrequency?: number;
    /**
     * The highest minimum effective frequency (the number of times a person was
     * exposed to the ad) value [1-10] to include in
     * Forecast.effective_frequency_breakdowns.
     * If not specified, Forecast.effective_frequency_breakdowns will not be
     * provided.
     *
     * The effective frequency value provided here will also be used as the
     * minimum effective frequency for the reported reach metrics.
     *
     * This field cannot be combined with the min_effective_frequency field.
     *
     * @generated from protobuf field: optional google.ads.googleads.v11.services.EffectiveFrequencyLimit effective_frequency_limit = 12;
     */
    effectiveFrequencyLimit?: EffectiveFrequencyLimit;
    /**
     * The targeting to be applied to all products selected in the product mix.
     *
     * This is planned targeting: execution details might vary based on the
     * advertising product, consult an implementation specialist.
     *
     * See specific metrics for details on how targeting affects them.
     *
     * @generated from protobuf field: google.ads.googleads.v11.services.Targeting targeting = 6;
     */
    targeting?: Targeting;
    /**
     * Required. The products to be forecast.
     * The max number of allowed planned products is 15.
     *
     * @generated from protobuf field: repeated google.ads.googleads.v11.services.PlannedProduct planned_products = 7;
     */
    plannedProducts: PlannedProduct[];
    /**
     * Controls the forecast metrics returned in the response.
     *
     * @generated from protobuf field: google.ads.googleads.v11.services.ForecastMetricOptions forecast_metric_options = 13;
     */
    forecastMetricOptions?: ForecastMetricOptions;
    /**
     * The name of the customer being planned for. This is a user-defined value.
     * Required if targeting.audience_targeting is set.
     *
     * @generated from protobuf field: optional string customer_reach_group = 14;
     */
    customerReachGroup?: string;
}
/**
 * Effective frequency limit.
 *
 * @generated from protobuf message google.ads.googleads.v11.services.EffectiveFrequencyLimit
 */
export interface EffectiveFrequencyLimit {
    /**
     * The highest effective frequency value to include in
     * Forecast.effective_frequency_breakdowns.
     * This field supports frequencies 1-10, inclusive.
     *
     * @generated from protobuf field: int32 effective_frequency_breakdown_limit = 1;
     */
    effectiveFrequencyBreakdownLimit: number;
}
/**
 * A rule specifying the maximum number of times an ad can be shown to a user
 * over a particular time period.
 *
 * @generated from protobuf message google.ads.googleads.v11.services.FrequencyCap
 */
export interface FrequencyCap {
    /**
     * Required. The number of impressions, inclusive.
     *
     * @generated from protobuf field: int32 impressions = 3;
     */
    impressions: number;
    /**
     * Required. The type of time unit.
     *
     * @generated from protobuf field: google.ads.googleads.v11.enums.FrequencyCapTimeUnitEnum.FrequencyCapTimeUnit time_unit = 2;
     */
    timeUnit: FrequencyCapTimeUnitEnum_FrequencyCapTimeUnit;
}
/**
 * The targeting for which traffic metrics will be reported.
 *
 * @generated from protobuf message google.ads.googleads.v11.services.Targeting
 */
export interface Targeting {
    /**
     * Required. The ID of the selected location. Plannable location IDs can be
     * obtained from [ReachPlanService.ListPlannableLocations][google.ads.googleads.v11.services.ReachPlanService.ListPlannableLocations].
     *
     * @generated from protobuf field: optional string plannable_location_id = 6;
     */
    plannableLocationId?: string;
    /**
     * Targeted age range.
     * An unset value is equivalent to targeting all ages.
     *
     * @generated from protobuf field: google.ads.googleads.v11.enums.ReachPlanAgeRangeEnum.ReachPlanAgeRange age_range = 2;
     */
    ageRange: ReachPlanAgeRangeEnum_ReachPlanAgeRange;
    /**
     * Targeted genders.
     * An unset value is equivalent to targeting MALE and FEMALE.
     *
     * @generated from protobuf field: repeated google.ads.googleads.v11.common.GenderInfo genders = 3;
     */
    genders: GenderInfo[];
    /**
     * Targeted devices.
     * If not specified, targets all applicable devices. Applicable devices vary
     * by product and region and can be obtained from
     * [ReachPlanService.ListPlannableProducts][google.ads.googleads.v11.services.ReachPlanService.ListPlannableProducts].
     *
     * @generated from protobuf field: repeated google.ads.googleads.v11.common.DeviceInfo devices = 4;
     */
    devices: DeviceInfo[];
    /**
     * Targetable network for the ad product.
     * If not specified, targets all applicable networks. Applicable networks vary
     * by product and region and can be obtained from
     * [ReachPlanService.ListPlannableProducts][google.ads.googleads.v11.services.ReachPlanService.ListPlannableProducts].
     *
     * @generated from protobuf field: google.ads.googleads.v11.enums.ReachPlanNetworkEnum.ReachPlanNetwork network = 5;
     */
    network: ReachPlanNetworkEnum_ReachPlanNetwork;
    /**
     * Targeted audiences.
     * If not specified, does not target any specific audience.
     *
     * @generated from protobuf field: google.ads.googleads.v11.services.AudienceTargeting audience_targeting = 7;
     */
    audienceTargeting?: AudienceTargeting;
}
/**
 * The duration of a planned campaign.
 *
 * @generated from protobuf message google.ads.googleads.v11.services.CampaignDuration
 */
export interface CampaignDuration {
    /**
     * The duration value in days.
     *
     * This field cannot be combined with the date_range field.
     *
     * @generated from protobuf field: optional int32 duration_in_days = 2;
     */
    durationInDays?: number;
    /**
     * Date range of the campaign.
     * Dates are in the yyyy-mm-dd format and inclusive.
     * The end date must be < 1 year in the future and the
     * date range must be <= 92 days long.
     *
     * This field cannot be combined with the duration_in_days field.
     *
     * @generated from protobuf field: google.ads.googleads.v11.common.DateRange date_range = 3;
     */
    dateRange?: DateRange;
}
/**
 * A product being planned for reach.
 *
 * @generated from protobuf message google.ads.googleads.v11.services.PlannedProduct
 */
export interface PlannedProduct {
    /**
     * Required. Selected product for planning.
     * The code associated with the ad product (for example: Trueview, Bumper).
     * To list the available plannable product codes use
     * [ReachPlanService.ListPlannableProducts][google.ads.googleads.v11.services.ReachPlanService.ListPlannableProducts].
     *
     * @generated from protobuf field: optional string plannable_product_code = 3;
     */
    plannableProductCode?: string;
    /**
     * Required. Maximum budget allocation in micros for the selected product.
     * The value is specified in the selected planning currency_code.
     * For example: 1 000 000$ = 1 000 000 000 000 micros.
     *
     * @generated from protobuf field: optional int64 budget_micros = 4;
     */
    budgetMicros?: bigint;
    /**
     * Targeting settings for the selected product.
     * To list the available targeting for each product use
     * [ReachPlanService.ListPlannableProducts][google.ads.googleads.v11.services.ReachPlanService.ListPlannableProducts].
     *
     * @generated from protobuf field: google.ads.googleads.v11.services.AdvancedProductTargeting advanced_product_targeting = 5;
     */
    advancedProductTargeting?: AdvancedProductTargeting;
}
/**
 * Response message containing the generated reach curve.
 *
 * @generated from protobuf message google.ads.googleads.v11.services.GenerateReachForecastResponse
 */
export interface GenerateReachForecastResponse {
    /**
     * Reference on target audiences for this curve.
     *
     * @generated from protobuf field: google.ads.googleads.v11.services.OnTargetAudienceMetrics on_target_audience_metrics = 1;
     */
    onTargetAudienceMetrics?: OnTargetAudienceMetrics;
    /**
     * The generated reach curve for the planned product mix.
     *
     * @generated from protobuf field: google.ads.googleads.v11.services.ReachCurve reach_curve = 2;
     */
    reachCurve?: ReachCurve;
}
/**
 * The reach curve for the planned products.
 *
 * @generated from protobuf message google.ads.googleads.v11.services.ReachCurve
 */
export interface ReachCurve {
    /**
     * All points on the reach curve.
     *
     * @generated from protobuf field: repeated google.ads.googleads.v11.services.ReachForecast reach_forecasts = 1;
     */
    reachForecasts: ReachForecast[];
}
/**
 * A point on reach curve.
 *
 * @generated from protobuf message google.ads.googleads.v11.services.ReachForecast
 */
export interface ReachForecast {
    /**
     * The cost in micros.
     *
     * @generated from protobuf field: int64 cost_micros = 5;
     */
    costMicros: bigint;
    /**
     * Forecasted traffic metrics for this point.
     *
     * @generated from protobuf field: google.ads.googleads.v11.services.Forecast forecast = 2;
     */
    forecast?: Forecast;
    /**
     * The forecasted allocation and traffic metrics for each planned product
     * at this point on the reach curve.
     *
     * @generated from protobuf field: repeated google.ads.googleads.v11.services.PlannedProductReachForecast planned_product_reach_forecasts = 4;
     */
    plannedProductReachForecasts: PlannedProductReachForecast[];
}
/**
 * Forecasted traffic metrics for the planned products and targeting.
 *
 * @generated from protobuf message google.ads.googleads.v11.services.Forecast
 */
export interface Forecast {
    /**
     * Number of unique people reached at least
     * GenerateReachForecastRequest.min_effective_frequency or
     * GenerateReachForecastRequest.effective_frequency_limit times that exactly
     * matches the Targeting.
     *
     * Note that a minimum number of unique people must be reached in order for
     * data to be reported. If the minimum number is not met, the on_target_reach
     * value will be rounded to 0.
     *
     * @generated from protobuf field: optional int64 on_target_reach = 5;
     */
    onTargetReach?: bigint;
    /**
     * Total number of unique people reached at least
     * GenerateReachForecastRequest.min_effective_frequency or
     * GenerateReachForecastRequest.effective_frequency_limit times. This includes
     * people that may fall outside the specified Targeting.
     *
     * Note that a minimum number of unique people must be reached in order for
     * data to be reported. If the minimum number is not met, the total_reach
     * value will be rounded to 0.
     *
     * @generated from protobuf field: optional int64 total_reach = 6;
     */
    totalReach?: bigint;
    /**
     * Number of ad impressions that exactly matches the Targeting.
     *
     * @generated from protobuf field: optional int64 on_target_impressions = 7;
     */
    onTargetImpressions?: bigint;
    /**
     * Total number of ad impressions. This includes impressions that may fall
     * outside the specified Targeting, due to insufficient information on
     * signed-in users.
     *
     * @generated from protobuf field: optional int64 total_impressions = 8;
     */
    totalImpressions?: bigint;
    /**
     * Number of times the ad's impressions were considered viewable.
     * See https://support.google.com/google-ads/answer/7029393 for
     * more information about what makes an ad viewable and how
     * viewability is measured.
     *
     * @generated from protobuf field: optional int64 viewable_impressions = 9;
     */
    viewableImpressions?: bigint;
    /**
     * A list of effective frequency forecasts. The list is ordered starting with
     * 1+ and ending with the value set in
     * GenerateReachForecastRequest.effective_frequency_limit. If no
     * effective_frequency_limit was set, this list will be empty.
     *
     * @generated from protobuf field: repeated google.ads.googleads.v11.services.EffectiveFrequencyBreakdown effective_frequency_breakdowns = 10;
     */
    effectiveFrequencyBreakdowns: EffectiveFrequencyBreakdown[];
    /**
     * Number of unique people reached that exactly matches the Targeting
     * including co-viewers.
     *
     * @generated from protobuf field: optional int64 on_target_coview_reach = 11;
     */
    onTargetCoviewReach?: bigint;
    /**
     * Number of unique people reached including co-viewers. This includes
     * people that may fall outside the specified Targeting.
     *
     * @generated from protobuf field: optional int64 total_coview_reach = 12;
     */
    totalCoviewReach?: bigint;
    /**
     * Number of ad impressions that exactly matches the Targeting including
     * co-viewers.
     *
     * @generated from protobuf field: optional int64 on_target_coview_impressions = 13;
     */
    onTargetCoviewImpressions?: bigint;
    /**
     * Total number of ad impressions including co-viewers. This includes
     * impressions that may fall outside the specified Targeting, due to
     * insufficient information on signed-in users.
     *
     * @generated from protobuf field: optional int64 total_coview_impressions = 14;
     */
    totalCoviewImpressions?: bigint;
}
/**
 * The forecasted allocation and traffic metrics for a specific product
 * at a point on the reach curve.
 *
 * @generated from protobuf message google.ads.googleads.v11.services.PlannedProductReachForecast
 */
export interface PlannedProductReachForecast {
    /**
     * Selected product for planning. The product codes returned are within the
     * set of the ones returned by ListPlannableProducts when using the same
     * location ID.
     *
     * @generated from protobuf field: string plannable_product_code = 1;
     */
    plannableProductCode: string;
    /**
     * The cost in micros. This may differ from the product's input allocation
     * if one or more planned products cannot fulfill the budget because of
     * limited inventory.
     *
     * @generated from protobuf field: int64 cost_micros = 2;
     */
    costMicros: bigint;
    /**
     * Forecasted traffic metrics for this product.
     *
     * @generated from protobuf field: google.ads.googleads.v11.services.PlannedProductForecast planned_product_forecast = 3;
     */
    plannedProductForecast?: PlannedProductForecast;
}
/**
 * Forecasted traffic metrics for a planned product.
 *
 * @generated from protobuf message google.ads.googleads.v11.services.PlannedProductForecast
 */
export interface PlannedProductForecast {
    /**
     * Number of unique people reached that exactly matches the Targeting.
     *
     * Note that a minimum number of unique people must be reached in order for
     * data to be reported. If the minimum number is not met, the on_target_reach
     * value will be rounded to 0.
     *
     * @generated from protobuf field: int64 on_target_reach = 1;
     */
    onTargetReach: bigint;
    /**
     * Number of unique people reached. This includes people that may fall
     * outside the specified Targeting.
     *
     * Note that a minimum number of unique people must be reached in order for
     * data to be reported. If the minimum number is not met, the total_reach
     * value will be rounded to 0.
     *
     * @generated from protobuf field: int64 total_reach = 2;
     */
    totalReach: bigint;
    /**
     * Number of ad impressions that exactly matches the Targeting.
     *
     * @generated from protobuf field: int64 on_target_impressions = 3;
     */
    onTargetImpressions: bigint;
    /**
     * Total number of ad impressions. This includes impressions that may fall
     * outside the specified Targeting, due to insufficient information on
     * signed-in users.
     *
     * @generated from protobuf field: int64 total_impressions = 4;
     */
    totalImpressions: bigint;
    /**
     * Number of times the ad's impressions were considered viewable.
     * See https://support.google.com/google-ads/answer/7029393 for
     * more information about what makes an ad viewable and how
     * viewability is measured.
     *
     * @generated from protobuf field: optional int64 viewable_impressions = 5;
     */
    viewableImpressions?: bigint;
    /**
     * Number of unique people reached that exactly matches the Targeting
     * including co-viewers.
     *
     * @generated from protobuf field: optional int64 on_target_coview_reach = 6;
     */
    onTargetCoviewReach?: bigint;
    /**
     * Number of unique people reached including co-viewers. This includes
     * people that may fall outside the specified Targeting.
     *
     * @generated from protobuf field: optional int64 total_coview_reach = 7;
     */
    totalCoviewReach?: bigint;
    /**
     * Number of ad impressions that exactly matches the Targeting including
     * co-viewers.
     *
     * @generated from protobuf field: optional int64 on_target_coview_impressions = 8;
     */
    onTargetCoviewImpressions?: bigint;
    /**
     * Total number of ad impressions including co-viewers. This includes
     * impressions that may fall outside the specified Targeting, due to
     * insufficient information on signed-in users.
     *
     * @generated from protobuf field: optional int64 total_coview_impressions = 9;
     */
    totalCoviewImpressions?: bigint;
}
/**
 * Audience metrics for the planned products.
 * These metrics consider the following targeting dimensions:
 *
 * - Location
 * - PlannableAgeRange
 * - Gender
 *
 * @generated from protobuf message google.ads.googleads.v11.services.OnTargetAudienceMetrics
 */
export interface OnTargetAudienceMetrics {
    /**
     * Reference audience size matching the considered targeting for YouTube.
     *
     * @generated from protobuf field: optional int64 youtube_audience_size = 3;
     */
    youtubeAudienceSize?: bigint;
    /**
     * Reference audience size matching the considered targeting for Census.
     *
     * @generated from protobuf field: optional int64 census_audience_size = 4;
     */
    censusAudienceSize?: bigint;
}
/**
 * A breakdown of the number of unique people reached at a given effective
 * frequency.
 *
 * @generated from protobuf message google.ads.googleads.v11.services.EffectiveFrequencyBreakdown
 */
export interface EffectiveFrequencyBreakdown {
    /**
     * The effective frequency [1-10].
     *
     * @generated from protobuf field: int32 effective_frequency = 1;
     */
    effectiveFrequency: number;
    /**
     * The number of unique people reached at least effective_frequency times that
     * exactly matches the Targeting.
     *
     * Note that a minimum number of unique people must be reached in order for
     * data to be reported. If the minimum number is not met, the on_target_reach
     * value will be rounded to 0.
     *
     * @generated from protobuf field: int64 on_target_reach = 2;
     */
    onTargetReach: bigint;
    /**
     * Total number of unique people reached at least effective_frequency times.
     * This includes people that may fall outside the specified Targeting.
     *
     * Note that a minimum number of unique people must be reached in order for
     * data to be reported. If the minimum number is not met, the total_reach
     * value will be rounded to 0.
     *
     * @generated from protobuf field: int64 total_reach = 3;
     */
    totalReach: bigint;
    /**
     * The number of users (including co-viewing users) reached for the associated
     * effective_frequency value.
     *
     * @generated from protobuf field: optional int64 effective_coview_reach = 4;
     */
    effectiveCoviewReach?: bigint;
    /**
     * The number of users (including co-viewing users) reached for the associated
     * effective_frequency value within the specified plan demographic.
     *
     * @generated from protobuf field: optional int64 on_target_effective_coview_reach = 5;
     */
    onTargetEffectiveCoviewReach?: bigint;
}
/**
 * Controls forecast metrics to return.
 *
 * @generated from protobuf message google.ads.googleads.v11.services.ForecastMetricOptions
 */
export interface ForecastMetricOptions {
    /**
     * Indicates whether to include co-view metrics in the response forecast.
     *
     * @generated from protobuf field: bool include_coview = 1;
     */
    includeCoview: boolean;
}
/**
 * Audience targeting for reach forecast.
 *
 * @generated from protobuf message google.ads.googleads.v11.services.AudienceTargeting
 */
export interface AudienceTargeting {
    /**
     * List of audiences based on user interests to be targeted.
     *
     * @generated from protobuf field: repeated google.ads.googleads.v11.common.UserInterestInfo user_interest = 1;
     */
    userInterest: UserInterestInfo[];
}
/**
 * Advanced targeting settings for products.
 *
 * @generated from protobuf message google.ads.googleads.v11.services.AdvancedProductTargeting
 */
export interface AdvancedProductTargeting {
    /**
     * @generated from protobuf oneof: advanced_targeting
     */
    advancedTargeting: {
        oneofKind: "youtubeSelectSettings";
        /**
         * Settings for YouTube Select targeting.
         *
         * @generated from protobuf field: google.ads.googleads.v11.services.YouTubeSelectSettings youtube_select_settings = 1;
         */
        youtubeSelectSettings: YouTubeSelectSettings;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Request settings for YouTube Select Lineups
 *
 * @generated from protobuf message google.ads.googleads.v11.services.YouTubeSelectSettings
 */
export interface YouTubeSelectSettings {
    /**
     * Lineup for YouTube Select Targeting.
     *
     * @generated from protobuf field: int64 lineup_id = 1;
     */
    lineupId: bigint;
}
/**
 * A Plannable YouTube Select Lineup for product targeting.
 *
 * @generated from protobuf message google.ads.googleads.v11.services.YouTubeSelectLineUp
 */
export interface YouTubeSelectLineUp {
    /**
     * The ID of the YouTube Select Lineup.
     *
     * @generated from protobuf field: int64 lineup_id = 1;
     */
    lineupId: bigint;
    /**
     * The unique name of the YouTube Select Lineup.
     *
     * @generated from protobuf field: string lineup_name = 2;
     */
    lineupName: string;
}
declare class ListPlannableLocationsRequest$Type extends MessageType<ListPlannableLocationsRequest> {
    constructor();
    create(value?: PartialMessage<ListPlannableLocationsRequest>): ListPlannableLocationsRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListPlannableLocationsRequest): ListPlannableLocationsRequest;
    internalBinaryWrite(message: ListPlannableLocationsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message google.ads.googleads.v11.services.ListPlannableLocationsRequest
 */
export declare const ListPlannableLocationsRequest: ListPlannableLocationsRequest$Type;
declare class ListPlannableLocationsResponse$Type extends MessageType<ListPlannableLocationsResponse> {
    constructor();
    create(value?: PartialMessage<ListPlannableLocationsResponse>): ListPlannableLocationsResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListPlannableLocationsResponse): ListPlannableLocationsResponse;
    internalBinaryWrite(message: ListPlannableLocationsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message google.ads.googleads.v11.services.ListPlannableLocationsResponse
 */
export declare const ListPlannableLocationsResponse: ListPlannableLocationsResponse$Type;
declare class PlannableLocation$Type extends MessageType<PlannableLocation> {
    constructor();
    create(value?: PartialMessage<PlannableLocation>): PlannableLocation;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlannableLocation): PlannableLocation;
    internalBinaryWrite(message: PlannableLocation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message google.ads.googleads.v11.services.PlannableLocation
 */
export declare const PlannableLocation: PlannableLocation$Type;
declare class ListPlannableProductsRequest$Type extends MessageType<ListPlannableProductsRequest> {
    constructor();
    create(value?: PartialMessage<ListPlannableProductsRequest>): ListPlannableProductsRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListPlannableProductsRequest): ListPlannableProductsRequest;
    internalBinaryWrite(message: ListPlannableProductsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message google.ads.googleads.v11.services.ListPlannableProductsRequest
 */
export declare const ListPlannableProductsRequest: ListPlannableProductsRequest$Type;
declare class ListPlannableProductsResponse$Type extends MessageType<ListPlannableProductsResponse> {
    constructor();
    create(value?: PartialMessage<ListPlannableProductsResponse>): ListPlannableProductsResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListPlannableProductsResponse): ListPlannableProductsResponse;
    internalBinaryWrite(message: ListPlannableProductsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message google.ads.googleads.v11.services.ListPlannableProductsResponse
 */
export declare const ListPlannableProductsResponse: ListPlannableProductsResponse$Type;
declare class ProductMetadata$Type extends MessageType<ProductMetadata> {
    constructor();
    create(value?: PartialMessage<ProductMetadata>): ProductMetadata;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProductMetadata): ProductMetadata;
    internalBinaryWrite(message: ProductMetadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message google.ads.googleads.v11.services.ProductMetadata
 */
export declare const ProductMetadata: ProductMetadata$Type;
declare class PlannableTargeting$Type extends MessageType<PlannableTargeting> {
    constructor();
    create(value?: PartialMessage<PlannableTargeting>): PlannableTargeting;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlannableTargeting): PlannableTargeting;
    internalBinaryWrite(message: PlannableTargeting, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message google.ads.googleads.v11.services.PlannableTargeting
 */
export declare const PlannableTargeting: PlannableTargeting$Type;
declare class GenerateProductMixIdeasRequest$Type extends MessageType<GenerateProductMixIdeasRequest> {
    constructor();
    create(value?: PartialMessage<GenerateProductMixIdeasRequest>): GenerateProductMixIdeasRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GenerateProductMixIdeasRequest): GenerateProductMixIdeasRequest;
    internalBinaryWrite(message: GenerateProductMixIdeasRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message google.ads.googleads.v11.services.GenerateProductMixIdeasRequest
 */
export declare const GenerateProductMixIdeasRequest: GenerateProductMixIdeasRequest$Type;
declare class Preferences$Type extends MessageType<Preferences> {
    constructor();
    create(value?: PartialMessage<Preferences>): Preferences;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Preferences): Preferences;
    internalBinaryWrite(message: Preferences, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message google.ads.googleads.v11.services.Preferences
 */
export declare const Preferences: Preferences$Type;
declare class GenerateProductMixIdeasResponse$Type extends MessageType<GenerateProductMixIdeasResponse> {
    constructor();
    create(value?: PartialMessage<GenerateProductMixIdeasResponse>): GenerateProductMixIdeasResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GenerateProductMixIdeasResponse): GenerateProductMixIdeasResponse;
    internalBinaryWrite(message: GenerateProductMixIdeasResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message google.ads.googleads.v11.services.GenerateProductMixIdeasResponse
 */
export declare const GenerateProductMixIdeasResponse: GenerateProductMixIdeasResponse$Type;
declare class ProductAllocation$Type extends MessageType<ProductAllocation> {
    constructor();
    create(value?: PartialMessage<ProductAllocation>): ProductAllocation;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProductAllocation): ProductAllocation;
    internalBinaryWrite(message: ProductAllocation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message google.ads.googleads.v11.services.ProductAllocation
 */
export declare const ProductAllocation: ProductAllocation$Type;
declare class GenerateReachForecastRequest$Type extends MessageType<GenerateReachForecastRequest> {
    constructor();
    create(value?: PartialMessage<GenerateReachForecastRequest>): GenerateReachForecastRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GenerateReachForecastRequest): GenerateReachForecastRequest;
    internalBinaryWrite(message: GenerateReachForecastRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message google.ads.googleads.v11.services.GenerateReachForecastRequest
 */
export declare const GenerateReachForecastRequest: GenerateReachForecastRequest$Type;
declare class EffectiveFrequencyLimit$Type extends MessageType<EffectiveFrequencyLimit> {
    constructor();
    create(value?: PartialMessage<EffectiveFrequencyLimit>): EffectiveFrequencyLimit;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EffectiveFrequencyLimit): EffectiveFrequencyLimit;
    internalBinaryWrite(message: EffectiveFrequencyLimit, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message google.ads.googleads.v11.services.EffectiveFrequencyLimit
 */
export declare const EffectiveFrequencyLimit: EffectiveFrequencyLimit$Type;
declare class FrequencyCap$Type extends MessageType<FrequencyCap> {
    constructor();
    create(value?: PartialMessage<FrequencyCap>): FrequencyCap;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FrequencyCap): FrequencyCap;
    internalBinaryWrite(message: FrequencyCap, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message google.ads.googleads.v11.services.FrequencyCap
 */
export declare const FrequencyCap: FrequencyCap$Type;
declare class Targeting$Type extends MessageType<Targeting> {
    constructor();
    create(value?: PartialMessage<Targeting>): Targeting;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Targeting): Targeting;
    internalBinaryWrite(message: Targeting, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message google.ads.googleads.v11.services.Targeting
 */
export declare const Targeting: Targeting$Type;
declare class CampaignDuration$Type extends MessageType<CampaignDuration> {
    constructor();
    create(value?: PartialMessage<CampaignDuration>): CampaignDuration;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CampaignDuration): CampaignDuration;
    internalBinaryWrite(message: CampaignDuration, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message google.ads.googleads.v11.services.CampaignDuration
 */
export declare const CampaignDuration: CampaignDuration$Type;
declare class PlannedProduct$Type extends MessageType<PlannedProduct> {
    constructor();
    create(value?: PartialMessage<PlannedProduct>): PlannedProduct;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlannedProduct): PlannedProduct;
    internalBinaryWrite(message: PlannedProduct, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message google.ads.googleads.v11.services.PlannedProduct
 */
export declare const PlannedProduct: PlannedProduct$Type;
declare class GenerateReachForecastResponse$Type extends MessageType<GenerateReachForecastResponse> {
    constructor();
    create(value?: PartialMessage<GenerateReachForecastResponse>): GenerateReachForecastResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GenerateReachForecastResponse): GenerateReachForecastResponse;
    internalBinaryWrite(message: GenerateReachForecastResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message google.ads.googleads.v11.services.GenerateReachForecastResponse
 */
export declare const GenerateReachForecastResponse: GenerateReachForecastResponse$Type;
declare class ReachCurve$Type extends MessageType<ReachCurve> {
    constructor();
    create(value?: PartialMessage<ReachCurve>): ReachCurve;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReachCurve): ReachCurve;
    internalBinaryWrite(message: ReachCurve, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message google.ads.googleads.v11.services.ReachCurve
 */
export declare const ReachCurve: ReachCurve$Type;
declare class ReachForecast$Type extends MessageType<ReachForecast> {
    constructor();
    create(value?: PartialMessage<ReachForecast>): ReachForecast;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReachForecast): ReachForecast;
    internalBinaryWrite(message: ReachForecast, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message google.ads.googleads.v11.services.ReachForecast
 */
export declare const ReachForecast: ReachForecast$Type;
declare class Forecast$Type extends MessageType<Forecast> {
    constructor();
    create(value?: PartialMessage<Forecast>): Forecast;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Forecast): Forecast;
    internalBinaryWrite(message: Forecast, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message google.ads.googleads.v11.services.Forecast
 */
export declare const Forecast: Forecast$Type;
declare class PlannedProductReachForecast$Type extends MessageType<PlannedProductReachForecast> {
    constructor();
    create(value?: PartialMessage<PlannedProductReachForecast>): PlannedProductReachForecast;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlannedProductReachForecast): PlannedProductReachForecast;
    internalBinaryWrite(message: PlannedProductReachForecast, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message google.ads.googleads.v11.services.PlannedProductReachForecast
 */
export declare const PlannedProductReachForecast: PlannedProductReachForecast$Type;
declare class PlannedProductForecast$Type extends MessageType<PlannedProductForecast> {
    constructor();
    create(value?: PartialMessage<PlannedProductForecast>): PlannedProductForecast;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlannedProductForecast): PlannedProductForecast;
    internalBinaryWrite(message: PlannedProductForecast, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message google.ads.googleads.v11.services.PlannedProductForecast
 */
export declare const PlannedProductForecast: PlannedProductForecast$Type;
declare class OnTargetAudienceMetrics$Type extends MessageType<OnTargetAudienceMetrics> {
    constructor();
    create(value?: PartialMessage<OnTargetAudienceMetrics>): OnTargetAudienceMetrics;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OnTargetAudienceMetrics): OnTargetAudienceMetrics;
    internalBinaryWrite(message: OnTargetAudienceMetrics, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message google.ads.googleads.v11.services.OnTargetAudienceMetrics
 */
export declare const OnTargetAudienceMetrics: OnTargetAudienceMetrics$Type;
declare class EffectiveFrequencyBreakdown$Type extends MessageType<EffectiveFrequencyBreakdown> {
    constructor();
    create(value?: PartialMessage<EffectiveFrequencyBreakdown>): EffectiveFrequencyBreakdown;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EffectiveFrequencyBreakdown): EffectiveFrequencyBreakdown;
    internalBinaryWrite(message: EffectiveFrequencyBreakdown, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message google.ads.googleads.v11.services.EffectiveFrequencyBreakdown
 */
export declare const EffectiveFrequencyBreakdown: EffectiveFrequencyBreakdown$Type;
declare class ForecastMetricOptions$Type extends MessageType<ForecastMetricOptions> {
    constructor();
    create(value?: PartialMessage<ForecastMetricOptions>): ForecastMetricOptions;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ForecastMetricOptions): ForecastMetricOptions;
    internalBinaryWrite(message: ForecastMetricOptions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message google.ads.googleads.v11.services.ForecastMetricOptions
 */
export declare const ForecastMetricOptions: ForecastMetricOptions$Type;
declare class AudienceTargeting$Type extends MessageType<AudienceTargeting> {
    constructor();
    create(value?: PartialMessage<AudienceTargeting>): AudienceTargeting;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AudienceTargeting): AudienceTargeting;
    internalBinaryWrite(message: AudienceTargeting, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message google.ads.googleads.v11.services.AudienceTargeting
 */
export declare const AudienceTargeting: AudienceTargeting$Type;
declare class AdvancedProductTargeting$Type extends MessageType<AdvancedProductTargeting> {
    constructor();
    create(value?: PartialMessage<AdvancedProductTargeting>): AdvancedProductTargeting;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AdvancedProductTargeting): AdvancedProductTargeting;
    internalBinaryWrite(message: AdvancedProductTargeting, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message google.ads.googleads.v11.services.AdvancedProductTargeting
 */
export declare const AdvancedProductTargeting: AdvancedProductTargeting$Type;
declare class YouTubeSelectSettings$Type extends MessageType<YouTubeSelectSettings> {
    constructor();
    create(value?: PartialMessage<YouTubeSelectSettings>): YouTubeSelectSettings;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: YouTubeSelectSettings): YouTubeSelectSettings;
    internalBinaryWrite(message: YouTubeSelectSettings, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message google.ads.googleads.v11.services.YouTubeSelectSettings
 */
export declare const YouTubeSelectSettings: YouTubeSelectSettings$Type;
declare class YouTubeSelectLineUp$Type extends MessageType<YouTubeSelectLineUp> {
    constructor();
    create(value?: PartialMessage<YouTubeSelectLineUp>): YouTubeSelectLineUp;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: YouTubeSelectLineUp): YouTubeSelectLineUp;
    internalBinaryWrite(message: YouTubeSelectLineUp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message google.ads.googleads.v11.services.YouTubeSelectLineUp
 */
export declare const YouTubeSelectLineUp: YouTubeSelectLineUp$Type;
/**
 * @generated ServiceType for protobuf service google.ads.googleads.v11.services.ReachPlanService
 */
export declare const ReachPlanService: ServiceType;
export {};
