"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LoggingServiceV2Client = void 0;
const logging_1 = require("./logging");
const runtime_rpc_1 = require("@protobuf-ts/runtime-rpc");
/**
 * Service for ingesting and querying logs.
 *
 * @generated from protobuf service google.logging.v2.LoggingServiceV2
 */
class LoggingServiceV2Client {
    constructor(_transport) {
        this._transport = _transport;
        this.typeName = logging_1.LoggingServiceV2.typeName;
        this.methods = logging_1.LoggingServiceV2.methods;
        this.options = logging_1.LoggingServiceV2.options;
    }
    /**
     * Deletes all the log entries in a log for the _Default Log Bucket. The log
     * reappears if it receives new entries. Log entries written shortly before
     * the delete operation might not be deleted. Entries received after the
     * delete operation with a timestamp before the operation will be deleted.
     *
     * @generated from protobuf rpc: DeleteLog(google.logging.v2.DeleteLogRequest) returns (google.protobuf.Empty);
     */
    deleteLog(input, options) {
        const method = this.methods[0], opt = this._transport.mergeOptions(options);
        return (0, runtime_rpc_1.stackIntercept)("unary", this._transport, method, opt, input);
    }
    /**
     * Writes log entries to Logging. This API method is the
     * only way to send log entries to Logging. This method
     * is used, directly or indirectly, by the Logging agent
     * (fluentd) and all logging libraries configured to use Logging.
     * A single request may contain log entries for a maximum of 1000
     * different resources (projects, organizations, billing accounts or
     * folders)
     *
     * @generated from protobuf rpc: WriteLogEntries(google.logging.v2.WriteLogEntriesRequest) returns (google.logging.v2.WriteLogEntriesResponse);
     */
    writeLogEntries(input, options) {
        const method = this.methods[1], opt = this._transport.mergeOptions(options);
        return (0, runtime_rpc_1.stackIntercept)("unary", this._transport, method, opt, input);
    }
    /**
     * Lists log entries.  Use this method to retrieve log entries that originated
     * from a project/folder/organization/billing account.  For ways to export log
     * entries, see [Exporting
     * Logs](https://cloud.google.com/logging/docs/export).
     *
     * @generated from protobuf rpc: ListLogEntries(google.logging.v2.ListLogEntriesRequest) returns (google.logging.v2.ListLogEntriesResponse);
     */
    listLogEntries(input, options) {
        const method = this.methods[2], opt = this._transport.mergeOptions(options);
        return (0, runtime_rpc_1.stackIntercept)("unary", this._transport, method, opt, input);
    }
    /**
     * Lists the descriptors for monitored resource types used by Logging.
     *
     * @generated from protobuf rpc: ListMonitoredResourceDescriptors(google.logging.v2.ListMonitoredResourceDescriptorsRequest) returns (google.logging.v2.ListMonitoredResourceDescriptorsResponse);
     */
    listMonitoredResourceDescriptors(input, options) {
        const method = this.methods[3], opt = this._transport.mergeOptions(options);
        return (0, runtime_rpc_1.stackIntercept)("unary", this._transport, method, opt, input);
    }
    /**
     * Lists the logs in projects, organizations, folders, or billing accounts.
     * Only logs that have entries are listed.
     *
     * @generated from protobuf rpc: ListLogs(google.logging.v2.ListLogsRequest) returns (google.logging.v2.ListLogsResponse);
     */
    listLogs(input, options) {
        const method = this.methods[4], opt = this._transport.mergeOptions(options);
        return (0, runtime_rpc_1.stackIntercept)("unary", this._transport, method, opt, input);
    }
    /**
     * Streaming read of log entries as they are ingested. Until the stream is
     * terminated, it will continue reading logs.
     *
     * @generated from protobuf rpc: TailLogEntries(stream google.logging.v2.TailLogEntriesRequest) returns (stream google.logging.v2.TailLogEntriesResponse);
     */
    tailLogEntries(options) {
        const method = this.methods[5], opt = this._transport.mergeOptions(options);
        return (0, runtime_rpc_1.stackIntercept)("duplex", this._transport, method, opt);
    }
}
exports.LoggingServiceV2Client = LoggingServiceV2Client;
//# sourceMappingURL=logging.client.js.map