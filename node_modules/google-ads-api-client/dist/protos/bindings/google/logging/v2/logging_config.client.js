"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConfigServiceV2Client = void 0;
const logging_config_1 = require("./logging_config");
const runtime_rpc_1 = require("@protobuf-ts/runtime-rpc");
/**
 * Service for configuring sinks used to route log entries.
 *
 * @generated from protobuf service google.logging.v2.ConfigServiceV2
 */
class ConfigServiceV2Client {
    constructor(_transport) {
        this._transport = _transport;
        this.typeName = logging_config_1.ConfigServiceV2.typeName;
        this.methods = logging_config_1.ConfigServiceV2.methods;
        this.options = logging_config_1.ConfigServiceV2.options;
    }
    /**
     * Lists log buckets.
     *
     * @generated from protobuf rpc: ListBuckets(google.logging.v2.ListBucketsRequest) returns (google.logging.v2.ListBucketsResponse);
     */
    listBuckets(input, options) {
        const method = this.methods[0], opt = this._transport.mergeOptions(options);
        return (0, runtime_rpc_1.stackIntercept)("unary", this._transport, method, opt, input);
    }
    /**
     * Gets a log bucket.
     *
     * @generated from protobuf rpc: GetBucket(google.logging.v2.GetBucketRequest) returns (google.logging.v2.LogBucket);
     */
    getBucket(input, options) {
        const method = this.methods[1], opt = this._transport.mergeOptions(options);
        return (0, runtime_rpc_1.stackIntercept)("unary", this._transport, method, opt, input);
    }
    /**
     * Creates a log bucket that can be used to store log entries. After a bucket
     * has been created, the bucket's location cannot be changed.
     *
     * @generated from protobuf rpc: CreateBucket(google.logging.v2.CreateBucketRequest) returns (google.logging.v2.LogBucket);
     */
    createBucket(input, options) {
        const method = this.methods[2], opt = this._transport.mergeOptions(options);
        return (0, runtime_rpc_1.stackIntercept)("unary", this._transport, method, opt, input);
    }
    /**
     * Updates a log bucket. This method replaces the following fields in the
     * existing bucket with values from the new bucket: `retention_period`
     *
     * If the retention period is decreased and the bucket is locked,
     * `FAILED_PRECONDITION` will be returned.
     *
     * If the bucket has a `lifecycle_state` of `DELETE_REQUESTED`, then
     * `FAILED_PRECONDITION` will be returned.
     *
     * After a bucket has been created, the bucket's location cannot be changed.
     *
     * @generated from protobuf rpc: UpdateBucket(google.logging.v2.UpdateBucketRequest) returns (google.logging.v2.LogBucket);
     */
    updateBucket(input, options) {
        const method = this.methods[3], opt = this._transport.mergeOptions(options);
        return (0, runtime_rpc_1.stackIntercept)("unary", this._transport, method, opt, input);
    }
    /**
     * Deletes a log bucket.
     *
     * Changes the bucket's `lifecycle_state` to the `DELETE_REQUESTED` state.
     * After 7 days, the bucket will be purged and all log entries in the bucket
     * will be permanently deleted.
     *
     * @generated from protobuf rpc: DeleteBucket(google.logging.v2.DeleteBucketRequest) returns (google.protobuf.Empty);
     */
    deleteBucket(input, options) {
        const method = this.methods[4], opt = this._transport.mergeOptions(options);
        return (0, runtime_rpc_1.stackIntercept)("unary", this._transport, method, opt, input);
    }
    /**
     * Undeletes a log bucket. A bucket that has been deleted can be undeleted
     * within the grace period of 7 days.
     *
     * @generated from protobuf rpc: UndeleteBucket(google.logging.v2.UndeleteBucketRequest) returns (google.protobuf.Empty);
     */
    undeleteBucket(input, options) {
        const method = this.methods[5], opt = this._transport.mergeOptions(options);
        return (0, runtime_rpc_1.stackIntercept)("unary", this._transport, method, opt, input);
    }
    /**
     * Lists views on a log bucket.
     *
     * @generated from protobuf rpc: ListViews(google.logging.v2.ListViewsRequest) returns (google.logging.v2.ListViewsResponse);
     */
    listViews(input, options) {
        const method = this.methods[6], opt = this._transport.mergeOptions(options);
        return (0, runtime_rpc_1.stackIntercept)("unary", this._transport, method, opt, input);
    }
    /**
     * Gets a view on a log bucket..
     *
     * @generated from protobuf rpc: GetView(google.logging.v2.GetViewRequest) returns (google.logging.v2.LogView);
     */
    getView(input, options) {
        const method = this.methods[7], opt = this._transport.mergeOptions(options);
        return (0, runtime_rpc_1.stackIntercept)("unary", this._transport, method, opt, input);
    }
    /**
     * Creates a view over log entries in a log bucket. A bucket may contain a
     * maximum of 30 views.
     *
     * @generated from protobuf rpc: CreateView(google.logging.v2.CreateViewRequest) returns (google.logging.v2.LogView);
     */
    createView(input, options) {
        const method = this.methods[8], opt = this._transport.mergeOptions(options);
        return (0, runtime_rpc_1.stackIntercept)("unary", this._transport, method, opt, input);
    }
    /**
     * Updates a view on a log bucket. This method replaces the following fields
     * in the existing view with values from the new view: `filter`.
     * If an `UNAVAILABLE` error is returned, this indicates that system is not in
     * a state where it can update the view. If this occurs, please try again in a
     * few minutes.
     *
     * @generated from protobuf rpc: UpdateView(google.logging.v2.UpdateViewRequest) returns (google.logging.v2.LogView);
     */
    updateView(input, options) {
        const method = this.methods[9], opt = this._transport.mergeOptions(options);
        return (0, runtime_rpc_1.stackIntercept)("unary", this._transport, method, opt, input);
    }
    /**
     * Deletes a view on a log bucket.
     * If an `UNAVAILABLE` error is returned, this indicates that system is not in
     * a state where it can delete the view. If this occurs, please try again in a
     * few minutes.
     *
     * @generated from protobuf rpc: DeleteView(google.logging.v2.DeleteViewRequest) returns (google.protobuf.Empty);
     */
    deleteView(input, options) {
        const method = this.methods[10], opt = this._transport.mergeOptions(options);
        return (0, runtime_rpc_1.stackIntercept)("unary", this._transport, method, opt, input);
    }
    /**
     * Lists sinks.
     *
     * @generated from protobuf rpc: ListSinks(google.logging.v2.ListSinksRequest) returns (google.logging.v2.ListSinksResponse);
     */
    listSinks(input, options) {
        const method = this.methods[11], opt = this._transport.mergeOptions(options);
        return (0, runtime_rpc_1.stackIntercept)("unary", this._transport, method, opt, input);
    }
    /**
     * Gets a sink.
     *
     * @generated from protobuf rpc: GetSink(google.logging.v2.GetSinkRequest) returns (google.logging.v2.LogSink);
     */
    getSink(input, options) {
        const method = this.methods[12], opt = this._transport.mergeOptions(options);
        return (0, runtime_rpc_1.stackIntercept)("unary", this._transport, method, opt, input);
    }
    /**
     * Creates a sink that exports specified log entries to a destination. The
     * export of newly-ingested log entries begins immediately, unless the sink's
     * `writer_identity` is not permitted to write to the destination. A sink can
     * export log entries only from the resource owning the sink.
     *
     * @generated from protobuf rpc: CreateSink(google.logging.v2.CreateSinkRequest) returns (google.logging.v2.LogSink);
     */
    createSink(input, options) {
        const method = this.methods[13], opt = this._transport.mergeOptions(options);
        return (0, runtime_rpc_1.stackIntercept)("unary", this._transport, method, opt, input);
    }
    /**
     * Updates a sink. This method replaces the following fields in the existing
     * sink with values from the new sink: `destination`, and `filter`.
     *
     * The updated sink might also have a new `writer_identity`; see the
     * `unique_writer_identity` field.
     *
     * @generated from protobuf rpc: UpdateSink(google.logging.v2.UpdateSinkRequest) returns (google.logging.v2.LogSink);
     */
    updateSink(input, options) {
        const method = this.methods[14], opt = this._transport.mergeOptions(options);
        return (0, runtime_rpc_1.stackIntercept)("unary", this._transport, method, opt, input);
    }
    /**
     * Deletes a sink. If the sink has a unique `writer_identity`, then that
     * service account is also deleted.
     *
     * @generated from protobuf rpc: DeleteSink(google.logging.v2.DeleteSinkRequest) returns (google.protobuf.Empty);
     */
    deleteSink(input, options) {
        const method = this.methods[15], opt = this._transport.mergeOptions(options);
        return (0, runtime_rpc_1.stackIntercept)("unary", this._transport, method, opt, input);
    }
    /**
     * Lists all the exclusions on the _Default sink in a parent resource.
     *
     * @generated from protobuf rpc: ListExclusions(google.logging.v2.ListExclusionsRequest) returns (google.logging.v2.ListExclusionsResponse);
     */
    listExclusions(input, options) {
        const method = this.methods[16], opt = this._transport.mergeOptions(options);
        return (0, runtime_rpc_1.stackIntercept)("unary", this._transport, method, opt, input);
    }
    /**
     * Gets the description of an exclusion in the _Default sink.
     *
     * @generated from protobuf rpc: GetExclusion(google.logging.v2.GetExclusionRequest) returns (google.logging.v2.LogExclusion);
     */
    getExclusion(input, options) {
        const method = this.methods[17], opt = this._transport.mergeOptions(options);
        return (0, runtime_rpc_1.stackIntercept)("unary", this._transport, method, opt, input);
    }
    /**
     * Creates a new exclusion in the _Default sink in a specified parent
     * resource. Only log entries belonging to that resource can be excluded. You
     * can have up to 10 exclusions in a resource.
     *
     * @generated from protobuf rpc: CreateExclusion(google.logging.v2.CreateExclusionRequest) returns (google.logging.v2.LogExclusion);
     */
    createExclusion(input, options) {
        const method = this.methods[18], opt = this._transport.mergeOptions(options);
        return (0, runtime_rpc_1.stackIntercept)("unary", this._transport, method, opt, input);
    }
    /**
     * Changes one or more properties of an existing exclusion in the _Default
     * sink.
     *
     * @generated from protobuf rpc: UpdateExclusion(google.logging.v2.UpdateExclusionRequest) returns (google.logging.v2.LogExclusion);
     */
    updateExclusion(input, options) {
        const method = this.methods[19], opt = this._transport.mergeOptions(options);
        return (0, runtime_rpc_1.stackIntercept)("unary", this._transport, method, opt, input);
    }
    /**
     * Deletes an exclusion in the _Default sink.
     *
     * @generated from protobuf rpc: DeleteExclusion(google.logging.v2.DeleteExclusionRequest) returns (google.protobuf.Empty);
     */
    deleteExclusion(input, options) {
        const method = this.methods[20], opt = this._transport.mergeOptions(options);
        return (0, runtime_rpc_1.stackIntercept)("unary", this._transport, method, opt, input);
    }
    /**
     * Gets the Logging CMEK settings for the given resource.
     *
     * Note: CMEK for the Log Router can be configured for Google Cloud projects,
     * folders, organizations and billing accounts. Once configured for an
     * organization, it applies to all projects and folders in the Google Cloud
     * organization.
     *
     * See [Enabling CMEK for Log
     * Router](https://cloud.google.com/logging/docs/routing/managed-encryption)
     * for more information.
     *
     * @generated from protobuf rpc: GetCmekSettings(google.logging.v2.GetCmekSettingsRequest) returns (google.logging.v2.CmekSettings);
     */
    getCmekSettings(input, options) {
        const method = this.methods[21], opt = this._transport.mergeOptions(options);
        return (0, runtime_rpc_1.stackIntercept)("unary", this._transport, method, opt, input);
    }
    /**
     * Updates the Log Router CMEK settings for the given resource.
     *
     * Note: CMEK for the Log Router can currently only be configured for Google
     * Cloud organizations. Once configured, it applies to all projects and
     * folders in the Google Cloud organization.
     *
     * [UpdateCmekSettings][google.logging.v2.ConfigServiceV2.UpdateCmekSettings]
     * will fail if 1) `kms_key_name` is invalid, or 2) the associated service
     * account does not have the required
     * `roles/cloudkms.cryptoKeyEncrypterDecrypter` role assigned for the key, or
     * 3) access to the key is disabled.
     *
     * See [Enabling CMEK for Log
     * Router](https://cloud.google.com/logging/docs/routing/managed-encryption)
     * for more information.
     *
     * @generated from protobuf rpc: UpdateCmekSettings(google.logging.v2.UpdateCmekSettingsRequest) returns (google.logging.v2.CmekSettings);
     */
    updateCmekSettings(input, options) {
        const method = this.methods[22], opt = this._transport.mergeOptions(options);
        return (0, runtime_rpc_1.stackIntercept)("unary", this._transport, method, opt, input);
    }
    /**
     * Gets the Log Router settings for the given resource.
     *
     * Note: Settings for the Log Router can be get for Google Cloud projects,
     * folders, organizations and billing accounts. Currently it can only be
     * configured for organizations. Once configured for an organization, it
     * applies to all projects and folders in the Google Cloud organization.
     *
     * See [Enabling CMEK for Log
     * Router](https://cloud.google.com/logging/docs/routing/managed-encryption)
     * for more information.
     *
     * @generated from protobuf rpc: GetSettings(google.logging.v2.GetSettingsRequest) returns (google.logging.v2.Settings);
     */
    getSettings(input, options) {
        const method = this.methods[23], opt = this._transport.mergeOptions(options);
        return (0, runtime_rpc_1.stackIntercept)("unary", this._transport, method, opt, input);
    }
    /**
     * Updates the Log Router settings for the given resource.
     *
     * Note: Settings for the Log Router can currently only be configured for
     * Google Cloud organizations. Once configured, it applies to all projects and
     * folders in the Google Cloud organization.
     *
     * [UpdateSettings][google.logging.v2.ConfigServiceV2.UpdateSettings]
     * will fail if 1) `kms_key_name` is invalid, or 2) the associated service
     * account does not have the required
     * `roles/cloudkms.cryptoKeyEncrypterDecrypter` role assigned for the key, or
     * 3) access to the key is disabled. 4) `location_id` is not supported by
     * Logging. 5) `location_id` violate OrgPolicy.
     *
     * See [Enabling CMEK for Log
     * Router](https://cloud.google.com/logging/docs/routing/managed-encryption)
     * for more information.
     *
     * @generated from protobuf rpc: UpdateSettings(google.logging.v2.UpdateSettingsRequest) returns (google.logging.v2.Settings);
     */
    updateSettings(input, options) {
        const method = this.methods[24], opt = this._transport.mergeOptions(options);
        return (0, runtime_rpc_1.stackIntercept)("unary", this._transport, method, opt, input);
    }
    /**
     * Copies a set of log entries from a log bucket to a Cloud Storage bucket.
     *
     * @generated from protobuf rpc: CopyLogEntries(google.logging.v2.CopyLogEntriesRequest) returns (google.longrunning.Operation);
     */
    copyLogEntries(input, options) {
        const method = this.methods[25], opt = this._transport.mergeOptions(options);
        return (0, runtime_rpc_1.stackIntercept)("unary", this._transport, method, opt, input);
    }
}
exports.ConfigServiceV2Client = ConfigServiceV2Client;
//# sourceMappingURL=logging_config.client.js.map