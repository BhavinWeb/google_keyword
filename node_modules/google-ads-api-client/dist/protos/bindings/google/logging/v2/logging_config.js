"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConfigServiceV2 = exports.CopyLogEntriesResponse = exports.CopyLogEntriesMetadata = exports.CopyLogEntriesRequest = exports.Settings = exports.UpdateSettingsRequest = exports.GetSettingsRequest = exports.CmekSettings = exports.UpdateCmekSettingsRequest = exports.GetCmekSettingsRequest = exports.DeleteExclusionRequest = exports.UpdateExclusionRequest = exports.CreateExclusionRequest = exports.GetExclusionRequest = exports.ListExclusionsResponse = exports.ListExclusionsRequest = exports.LogExclusion = exports.DeleteSinkRequest = exports.UpdateSinkRequest = exports.CreateSinkRequest = exports.GetSinkRequest = exports.ListSinksResponse = exports.ListSinksRequest = exports.DeleteViewRequest = exports.GetViewRequest = exports.UpdateViewRequest = exports.CreateViewRequest = exports.ListViewsResponse = exports.ListViewsRequest = exports.UndeleteBucketRequest = exports.DeleteBucketRequest = exports.GetBucketRequest = exports.UpdateBucketRequest = exports.CreateBucketRequest = exports.ListBucketsResponse = exports.ListBucketsRequest = exports.BigQueryOptions = exports.LogSink = exports.LogView = exports.LogBucket = exports.OperationState = exports.LifecycleState = exports.LogSink_VersionFormat = void 0;
// @generated by protobuf-ts 2.8.1
// @generated from protobuf file "google/logging/v2/logging_config.proto" (package "google.logging.v2", syntax proto3)
// tslint:disable
//
// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
const operations_1 = require("../../longrunning/operations");
const empty_1 = require("../../protobuf/empty");
const runtime_rpc_1 = require("@protobuf-ts/runtime-rpc");
const runtime_1 = require("@protobuf-ts/runtime");
const runtime_2 = require("@protobuf-ts/runtime");
const runtime_3 = require("@protobuf-ts/runtime");
const runtime_4 = require("@protobuf-ts/runtime");
const runtime_5 = require("@protobuf-ts/runtime");
const field_mask_1 = require("../../protobuf/field_mask");
const timestamp_1 = require("../../protobuf/timestamp");
/**
 * Deprecated. This is unused.
 *
 * @generated from protobuf enum google.logging.v2.LogSink.VersionFormat
 */
var LogSink_VersionFormat;
(function (LogSink_VersionFormat) {
    /**
     * An unspecified format version that will default to V2.
     *
     * @generated from protobuf enum value: VERSION_FORMAT_UNSPECIFIED = 0;
     */
    LogSink_VersionFormat[LogSink_VersionFormat["VERSION_FORMAT_UNSPECIFIED"] = 0] = "VERSION_FORMAT_UNSPECIFIED";
    /**
     * `LogEntry` version 2 format.
     *
     * @generated from protobuf enum value: V2 = 1;
     */
    LogSink_VersionFormat[LogSink_VersionFormat["V2"] = 1] = "V2";
    /**
     * `LogEntry` version 1 format.
     *
     * @generated from protobuf enum value: V1 = 2;
     */
    LogSink_VersionFormat[LogSink_VersionFormat["V1"] = 2] = "V1";
})(LogSink_VersionFormat = exports.LogSink_VersionFormat || (exports.LogSink_VersionFormat = {}));
/**
 * LogBucket lifecycle states.
 *
 * @generated from protobuf enum google.logging.v2.LifecycleState
 */
var LifecycleState;
(function (LifecycleState) {
    /**
     * Unspecified state. This is only used/useful for distinguishing unset
     * values.
     *
     * @generated from protobuf enum value: LIFECYCLE_STATE_UNSPECIFIED = 0;
     */
    LifecycleState[LifecycleState["LIFECYCLE_STATE_UNSPECIFIED"] = 0] = "LIFECYCLE_STATE_UNSPECIFIED";
    /**
     * The normal and active state.
     *
     * @generated from protobuf enum value: ACTIVE = 1;
     */
    LifecycleState[LifecycleState["ACTIVE"] = 1] = "ACTIVE";
    /**
     * The resource has been marked for deletion by the user. For some resources
     * (e.g. buckets), this can be reversed by an un-delete operation.
     *
     * @generated from protobuf enum value: DELETE_REQUESTED = 2;
     */
    LifecycleState[LifecycleState["DELETE_REQUESTED"] = 2] = "DELETE_REQUESTED";
})(LifecycleState = exports.LifecycleState || (exports.LifecycleState = {}));
/**
 * List of different operation states.
 * High level state of the operation. This is used to report the job's
 * current state to the user. Once a long running operation is created,
 * the current state of the operation can be queried even before the
 * operation is finished and the final result is available.
 *
 * @generated from protobuf enum google.logging.v2.OperationState
 */
var OperationState;
(function (OperationState) {
    /**
     * Should not be used.
     *
     * @generated from protobuf enum value: OPERATION_STATE_UNSPECIFIED = 0;
     */
    OperationState[OperationState["UNSPECIFIED"] = 0] = "UNSPECIFIED";
    /**
     * The operation is scheduled.
     *
     * @generated from protobuf enum value: OPERATION_STATE_SCHEDULED = 1;
     */
    OperationState[OperationState["SCHEDULED"] = 1] = "SCHEDULED";
    /**
     * Waiting for necessary permissions.
     *
     * @generated from protobuf enum value: OPERATION_STATE_WAITING_FOR_PERMISSIONS = 2;
     */
    OperationState[OperationState["WAITING_FOR_PERMISSIONS"] = 2] = "WAITING_FOR_PERMISSIONS";
    /**
     * The operation is running.
     *
     * @generated from protobuf enum value: OPERATION_STATE_RUNNING = 3;
     */
    OperationState[OperationState["RUNNING"] = 3] = "RUNNING";
    /**
     * The operation was completed successfully.
     *
     * @generated from protobuf enum value: OPERATION_STATE_SUCCEEDED = 4;
     */
    OperationState[OperationState["SUCCEEDED"] = 4] = "SUCCEEDED";
    /**
     * The operation failed.
     *
     * @generated from protobuf enum value: OPERATION_STATE_FAILED = 5;
     */
    OperationState[OperationState["FAILED"] = 5] = "FAILED";
    /**
     * The operation was cancelled by the user.
     *
     * @generated from protobuf enum value: OPERATION_STATE_CANCELLED = 6;
     */
    OperationState[OperationState["CANCELLED"] = 6] = "CANCELLED";
})(OperationState = exports.OperationState || (exports.OperationState = {}));
// @generated message type with reflection information, may provide speed optimized methods
class LogBucket$Type extends runtime_5.MessageType {
    constructor() {
        super("google.logging.v2.LogBucket", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["OUTPUT_ONLY"] } },
            { no: 3, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "create_time", kind: "message", T: () => timestamp_1.Timestamp, options: { "google.api.field_behavior": ["OUTPUT_ONLY"] } },
            { no: 5, name: "update_time", kind: "message", T: () => timestamp_1.Timestamp, options: { "google.api.field_behavior": ["OUTPUT_ONLY"] } },
            { no: 11, name: "retention_days", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "locked", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "lifecycle_state", kind: "enum", T: () => ["google.logging.v2.LifecycleState", LifecycleState], options: { "google.api.field_behavior": ["OUTPUT_ONLY"] } },
            { no: 15, name: "restricted_fields", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 19, name: "cmek_settings", kind: "message", T: () => exports.CmekSettings }
        ], { "google.api.resource": { type: "logging.googleapis.com/LogBucket", pattern: ["projects/{project}/locations/{location}/buckets/{bucket}", "organizations/{organization}/locations/{location}/buckets/{bucket}", "folders/{folder}/locations/{location}/buckets/{bucket}", "billingAccounts/{billing_account}/locations/{location}/buckets/{bucket}"] } });
    }
    create(value) {
        const message = { name: "", description: "", retentionDays: 0, locked: false, lifecycleState: 0, restrictedFields: [] };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string description */ 3:
                    message.description = reader.string();
                    break;
                case /* google.protobuf.Timestamp create_time */ 4:
                    message.createTime = timestamp_1.Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.createTime);
                    break;
                case /* google.protobuf.Timestamp update_time */ 5:
                    message.updateTime = timestamp_1.Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.updateTime);
                    break;
                case /* int32 retention_days */ 11:
                    message.retentionDays = reader.int32();
                    break;
                case /* bool locked */ 9:
                    message.locked = reader.bool();
                    break;
                case /* google.logging.v2.LifecycleState lifecycle_state */ 12:
                    message.lifecycleState = reader.int32();
                    break;
                case /* repeated string restricted_fields */ 15:
                    message.restrictedFields.push(reader.string());
                    break;
                case /* google.logging.v2.CmekSettings cmek_settings */ 19:
                    message.cmekSettings = exports.CmekSettings.internalBinaryRead(reader, reader.uint32(), options, message.cmekSettings);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.name);
        /* string description = 3; */
        if (message.description !== "")
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.description);
        /* google.protobuf.Timestamp create_time = 4; */
        if (message.createTime)
            timestamp_1.Timestamp.internalBinaryWrite(message.createTime, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp update_time = 5; */
        if (message.updateTime)
            timestamp_1.Timestamp.internalBinaryWrite(message.updateTime, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* int32 retention_days = 11; */
        if (message.retentionDays !== 0)
            writer.tag(11, runtime_1.WireType.Varint).int32(message.retentionDays);
        /* bool locked = 9; */
        if (message.locked !== false)
            writer.tag(9, runtime_1.WireType.Varint).bool(message.locked);
        /* google.logging.v2.LifecycleState lifecycle_state = 12; */
        if (message.lifecycleState !== 0)
            writer.tag(12, runtime_1.WireType.Varint).int32(message.lifecycleState);
        /* repeated string restricted_fields = 15; */
        for (let i = 0; i < message.restrictedFields.length; i++)
            writer.tag(15, runtime_1.WireType.LengthDelimited).string(message.restrictedFields[i]);
        /* google.logging.v2.CmekSettings cmek_settings = 19; */
        if (message.cmekSettings)
            exports.CmekSettings.internalBinaryWrite(message.cmekSettings, writer.tag(19, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.LogBucket
 */
exports.LogBucket = new LogBucket$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LogView$Type extends runtime_5.MessageType {
    constructor() {
        super("google.logging.v2.LogView", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "create_time", kind: "message", T: () => timestamp_1.Timestamp, options: { "google.api.field_behavior": ["OUTPUT_ONLY"] } },
            { no: 5, name: "update_time", kind: "message", T: () => timestamp_1.Timestamp, options: { "google.api.field_behavior": ["OUTPUT_ONLY"] } },
            { no: 7, name: "filter", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ], { "google.api.resource": { type: "logging.googleapis.com/LogView", pattern: ["projects/{project}/locations/{location}/buckets/{bucket}/views/{view}", "organizations/{organization}/locations/{location}/buckets/{bucket}/views/{view}", "folders/{folder}/locations/{location}/buckets/{bucket}/views/{view}", "billingAccounts/{billing_account}/locations/{location}/buckets/{bucket}/views/{view}"] } });
    }
    create(value) {
        const message = { name: "", description: "", filter: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string description */ 3:
                    message.description = reader.string();
                    break;
                case /* google.protobuf.Timestamp create_time */ 4:
                    message.createTime = timestamp_1.Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.createTime);
                    break;
                case /* google.protobuf.Timestamp update_time */ 5:
                    message.updateTime = timestamp_1.Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.updateTime);
                    break;
                case /* string filter */ 7:
                    message.filter = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.name);
        /* string description = 3; */
        if (message.description !== "")
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.description);
        /* google.protobuf.Timestamp create_time = 4; */
        if (message.createTime)
            timestamp_1.Timestamp.internalBinaryWrite(message.createTime, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp update_time = 5; */
        if (message.updateTime)
            timestamp_1.Timestamp.internalBinaryWrite(message.updateTime, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* string filter = 7; */
        if (message.filter !== "")
            writer.tag(7, runtime_1.WireType.LengthDelimited).string(message.filter);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.LogView
 */
exports.LogView = new LogView$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LogSink$Type extends runtime_5.MessageType {
    constructor() {
        super("google.logging.v2.LogSink", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 3, name: "destination", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"], "google.api.resource_reference": { type: "*" } } },
            { no: 5, name: "filter", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["OPTIONAL"] } },
            { no: 18, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["OPTIONAL"] } },
            { no: 19, name: "disabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/, options: { "google.api.field_behavior": ["OPTIONAL"] } },
            { no: 16, name: "exclusions", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => exports.LogExclusion, options: { "google.api.field_behavior": ["OPTIONAL"] } },
            { no: 6, name: "output_version_format", kind: "enum", T: () => ["google.logging.v2.LogSink.VersionFormat", LogSink_VersionFormat] },
            { no: 8, name: "writer_identity", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["OUTPUT_ONLY"] } },
            { no: 9, name: "include_children", kind: "scalar", T: 8 /*ScalarType.BOOL*/, options: { "google.api.field_behavior": ["OPTIONAL"] } },
            { no: 12, name: "bigquery_options", kind: "message", oneof: "options", T: () => exports.BigQueryOptions, options: { "google.api.field_behavior": ["OPTIONAL"] } },
            { no: 13, name: "create_time", kind: "message", T: () => timestamp_1.Timestamp, options: { "google.api.field_behavior": ["OUTPUT_ONLY"] } },
            { no: 14, name: "update_time", kind: "message", T: () => timestamp_1.Timestamp, options: { "google.api.field_behavior": ["OUTPUT_ONLY"] } }
        ], { "google.api.resource": { type: "logging.googleapis.com/LogSink", pattern: ["projects/{project}/sinks/{sink}", "organizations/{organization}/sinks/{sink}", "folders/{folder}/sinks/{sink}", "billingAccounts/{billing_account}/sinks/{sink}"] } });
    }
    create(value) {
        const message = { name: "", destination: "", filter: "", description: "", disabled: false, exclusions: [], outputVersionFormat: 0, writerIdentity: "", includeChildren: false, options: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string destination */ 3:
                    message.destination = reader.string();
                    break;
                case /* string filter */ 5:
                    message.filter = reader.string();
                    break;
                case /* string description */ 18:
                    message.description = reader.string();
                    break;
                case /* bool disabled */ 19:
                    message.disabled = reader.bool();
                    break;
                case /* repeated google.logging.v2.LogExclusion exclusions */ 16:
                    message.exclusions.push(exports.LogExclusion.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* google.logging.v2.LogSink.VersionFormat output_version_format = 6 [deprecated = true];*/ 6:
                    message.outputVersionFormat = reader.int32();
                    break;
                case /* string writer_identity */ 8:
                    message.writerIdentity = reader.string();
                    break;
                case /* bool include_children */ 9:
                    message.includeChildren = reader.bool();
                    break;
                case /* google.logging.v2.BigQueryOptions bigquery_options */ 12:
                    message.options = {
                        oneofKind: "bigqueryOptions",
                        bigqueryOptions: exports.BigQueryOptions.internalBinaryRead(reader, reader.uint32(), options, message.options.bigqueryOptions)
                    };
                    break;
                case /* google.protobuf.Timestamp create_time */ 13:
                    message.createTime = timestamp_1.Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.createTime);
                    break;
                case /* google.protobuf.Timestamp update_time */ 14:
                    message.updateTime = timestamp_1.Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.updateTime);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.name);
        /* string destination = 3; */
        if (message.destination !== "")
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.destination);
        /* string filter = 5; */
        if (message.filter !== "")
            writer.tag(5, runtime_1.WireType.LengthDelimited).string(message.filter);
        /* string description = 18; */
        if (message.description !== "")
            writer.tag(18, runtime_1.WireType.LengthDelimited).string(message.description);
        /* bool disabled = 19; */
        if (message.disabled !== false)
            writer.tag(19, runtime_1.WireType.Varint).bool(message.disabled);
        /* repeated google.logging.v2.LogExclusion exclusions = 16; */
        for (let i = 0; i < message.exclusions.length; i++)
            exports.LogExclusion.internalBinaryWrite(message.exclusions[i], writer.tag(16, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* google.logging.v2.LogSink.VersionFormat output_version_format = 6 [deprecated = true]; */
        if (message.outputVersionFormat !== 0)
            writer.tag(6, runtime_1.WireType.Varint).int32(message.outputVersionFormat);
        /* string writer_identity = 8; */
        if (message.writerIdentity !== "")
            writer.tag(8, runtime_1.WireType.LengthDelimited).string(message.writerIdentity);
        /* bool include_children = 9; */
        if (message.includeChildren !== false)
            writer.tag(9, runtime_1.WireType.Varint).bool(message.includeChildren);
        /* google.logging.v2.BigQueryOptions bigquery_options = 12; */
        if (message.options.oneofKind === "bigqueryOptions")
            exports.BigQueryOptions.internalBinaryWrite(message.options.bigqueryOptions, writer.tag(12, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp create_time = 13; */
        if (message.createTime)
            timestamp_1.Timestamp.internalBinaryWrite(message.createTime, writer.tag(13, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp update_time = 14; */
        if (message.updateTime)
            timestamp_1.Timestamp.internalBinaryWrite(message.updateTime, writer.tag(14, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.LogSink
 */
exports.LogSink = new LogSink$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BigQueryOptions$Type extends runtime_5.MessageType {
    constructor() {
        super("google.logging.v2.BigQueryOptions", [
            { no: 1, name: "use_partitioned_tables", kind: "scalar", T: 8 /*ScalarType.BOOL*/, options: { "google.api.field_behavior": ["OPTIONAL"] } },
            { no: 3, name: "uses_timestamp_column_partitioning", kind: "scalar", T: 8 /*ScalarType.BOOL*/, options: { "google.api.field_behavior": ["OUTPUT_ONLY"] } }
        ]);
    }
    create(value) {
        const message = { usePartitionedTables: false, usesTimestampColumnPartitioning: false };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool use_partitioned_tables */ 1:
                    message.usePartitionedTables = reader.bool();
                    break;
                case /* bool uses_timestamp_column_partitioning */ 3:
                    message.usesTimestampColumnPartitioning = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* bool use_partitioned_tables = 1; */
        if (message.usePartitionedTables !== false)
            writer.tag(1, runtime_1.WireType.Varint).bool(message.usePartitionedTables);
        /* bool uses_timestamp_column_partitioning = 3; */
        if (message.usesTimestampColumnPartitioning !== false)
            writer.tag(3, runtime_1.WireType.Varint).bool(message.usesTimestampColumnPartitioning);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.BigQueryOptions
 */
exports.BigQueryOptions = new BigQueryOptions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListBucketsRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("google.logging.v2.ListBucketsRequest", [
            { no: 1, name: "parent", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"], "google.api.resource_reference": { childType: "logging.googleapis.com/LogBucket" } } },
            { no: 2, name: "page_token", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["OPTIONAL"] } },
            { no: 3, name: "page_size", kind: "scalar", T: 5 /*ScalarType.INT32*/, options: { "google.api.field_behavior": ["OPTIONAL"] } }
        ]);
    }
    create(value) {
        const message = { parent: "", pageToken: "", pageSize: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string parent */ 1:
                    message.parent = reader.string();
                    break;
                case /* string page_token */ 2:
                    message.pageToken = reader.string();
                    break;
                case /* int32 page_size */ 3:
                    message.pageSize = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string parent = 1; */
        if (message.parent !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.parent);
        /* string page_token = 2; */
        if (message.pageToken !== "")
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.pageToken);
        /* int32 page_size = 3; */
        if (message.pageSize !== 0)
            writer.tag(3, runtime_1.WireType.Varint).int32(message.pageSize);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.ListBucketsRequest
 */
exports.ListBucketsRequest = new ListBucketsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListBucketsResponse$Type extends runtime_5.MessageType {
    constructor() {
        super("google.logging.v2.ListBucketsResponse", [
            { no: 1, name: "buckets", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => exports.LogBucket },
            { no: 2, name: "next_page_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = { buckets: [], nextPageToken: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated google.logging.v2.LogBucket buckets */ 1:
                    message.buckets.push(exports.LogBucket.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string next_page_token */ 2:
                    message.nextPageToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated google.logging.v2.LogBucket buckets = 1; */
        for (let i = 0; i < message.buckets.length; i++)
            exports.LogBucket.internalBinaryWrite(message.buckets[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* string next_page_token = 2; */
        if (message.nextPageToken !== "")
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.nextPageToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.ListBucketsResponse
 */
exports.ListBucketsResponse = new ListBucketsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateBucketRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("google.logging.v2.CreateBucketRequest", [
            { no: 1, name: "parent", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"], "google.api.resource_reference": { childType: "logging.googleapis.com/LogBucket" } } },
            { no: 2, name: "bucket_id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 3, name: "bucket", kind: "message", T: () => exports.LogBucket, options: { "google.api.field_behavior": ["REQUIRED"] } }
        ]);
    }
    create(value) {
        const message = { parent: "", bucketId: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string parent */ 1:
                    message.parent = reader.string();
                    break;
                case /* string bucket_id */ 2:
                    message.bucketId = reader.string();
                    break;
                case /* google.logging.v2.LogBucket bucket */ 3:
                    message.bucket = exports.LogBucket.internalBinaryRead(reader, reader.uint32(), options, message.bucket);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string parent = 1; */
        if (message.parent !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.parent);
        /* string bucket_id = 2; */
        if (message.bucketId !== "")
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.bucketId);
        /* google.logging.v2.LogBucket bucket = 3; */
        if (message.bucket)
            exports.LogBucket.internalBinaryWrite(message.bucket, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.CreateBucketRequest
 */
exports.CreateBucketRequest = new CreateBucketRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateBucketRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("google.logging.v2.UpdateBucketRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"], "google.api.resource_reference": { type: "logging.googleapis.com/LogBucket" } } },
            { no: 2, name: "bucket", kind: "message", T: () => exports.LogBucket, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 4, name: "update_mask", kind: "message", T: () => field_mask_1.FieldMask, options: { "google.api.field_behavior": ["REQUIRED"] } }
        ]);
    }
    create(value) {
        const message = { name: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* google.logging.v2.LogBucket bucket */ 2:
                    message.bucket = exports.LogBucket.internalBinaryRead(reader, reader.uint32(), options, message.bucket);
                    break;
                case /* google.protobuf.FieldMask update_mask */ 4:
                    message.updateMask = field_mask_1.FieldMask.internalBinaryRead(reader, reader.uint32(), options, message.updateMask);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.name);
        /* google.logging.v2.LogBucket bucket = 2; */
        if (message.bucket)
            exports.LogBucket.internalBinaryWrite(message.bucket, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.FieldMask update_mask = 4; */
        if (message.updateMask)
            field_mask_1.FieldMask.internalBinaryWrite(message.updateMask, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.UpdateBucketRequest
 */
exports.UpdateBucketRequest = new UpdateBucketRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetBucketRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("google.logging.v2.GetBucketRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"], "google.api.resource_reference": { type: "logging.googleapis.com/LogBucket" } } }
        ]);
    }
    create(value) {
        const message = { name: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.GetBucketRequest
 */
exports.GetBucketRequest = new GetBucketRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteBucketRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("google.logging.v2.DeleteBucketRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"], "google.api.resource_reference": { type: "logging.googleapis.com/LogBucket" } } }
        ]);
    }
    create(value) {
        const message = { name: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.DeleteBucketRequest
 */
exports.DeleteBucketRequest = new DeleteBucketRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UndeleteBucketRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("google.logging.v2.UndeleteBucketRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"], "google.api.resource_reference": { type: "logging.googleapis.com/LogBucket" } } }
        ]);
    }
    create(value) {
        const message = { name: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.UndeleteBucketRequest
 */
exports.UndeleteBucketRequest = new UndeleteBucketRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListViewsRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("google.logging.v2.ListViewsRequest", [
            { no: 1, name: "parent", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 2, name: "page_token", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["OPTIONAL"] } },
            { no: 3, name: "page_size", kind: "scalar", T: 5 /*ScalarType.INT32*/, options: { "google.api.field_behavior": ["OPTIONAL"] } }
        ]);
    }
    create(value) {
        const message = { parent: "", pageToken: "", pageSize: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string parent */ 1:
                    message.parent = reader.string();
                    break;
                case /* string page_token */ 2:
                    message.pageToken = reader.string();
                    break;
                case /* int32 page_size */ 3:
                    message.pageSize = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string parent = 1; */
        if (message.parent !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.parent);
        /* string page_token = 2; */
        if (message.pageToken !== "")
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.pageToken);
        /* int32 page_size = 3; */
        if (message.pageSize !== 0)
            writer.tag(3, runtime_1.WireType.Varint).int32(message.pageSize);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.ListViewsRequest
 */
exports.ListViewsRequest = new ListViewsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListViewsResponse$Type extends runtime_5.MessageType {
    constructor() {
        super("google.logging.v2.ListViewsResponse", [
            { no: 1, name: "views", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => exports.LogView },
            { no: 2, name: "next_page_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = { views: [], nextPageToken: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated google.logging.v2.LogView views */ 1:
                    message.views.push(exports.LogView.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string next_page_token */ 2:
                    message.nextPageToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated google.logging.v2.LogView views = 1; */
        for (let i = 0; i < message.views.length; i++)
            exports.LogView.internalBinaryWrite(message.views[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* string next_page_token = 2; */
        if (message.nextPageToken !== "")
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.nextPageToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.ListViewsResponse
 */
exports.ListViewsResponse = new ListViewsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateViewRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("google.logging.v2.CreateViewRequest", [
            { no: 1, name: "parent", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 2, name: "view_id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 3, name: "view", kind: "message", T: () => exports.LogView, options: { "google.api.field_behavior": ["REQUIRED"] } }
        ]);
    }
    create(value) {
        const message = { parent: "", viewId: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string parent */ 1:
                    message.parent = reader.string();
                    break;
                case /* string view_id */ 2:
                    message.viewId = reader.string();
                    break;
                case /* google.logging.v2.LogView view */ 3:
                    message.view = exports.LogView.internalBinaryRead(reader, reader.uint32(), options, message.view);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string parent = 1; */
        if (message.parent !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.parent);
        /* string view_id = 2; */
        if (message.viewId !== "")
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.viewId);
        /* google.logging.v2.LogView view = 3; */
        if (message.view)
            exports.LogView.internalBinaryWrite(message.view, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.CreateViewRequest
 */
exports.CreateViewRequest = new CreateViewRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateViewRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("google.logging.v2.UpdateViewRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 2, name: "view", kind: "message", T: () => exports.LogView, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 4, name: "update_mask", kind: "message", T: () => field_mask_1.FieldMask, options: { "google.api.field_behavior": ["OPTIONAL"] } }
        ]);
    }
    create(value) {
        const message = { name: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* google.logging.v2.LogView view */ 2:
                    message.view = exports.LogView.internalBinaryRead(reader, reader.uint32(), options, message.view);
                    break;
                case /* google.protobuf.FieldMask update_mask */ 4:
                    message.updateMask = field_mask_1.FieldMask.internalBinaryRead(reader, reader.uint32(), options, message.updateMask);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.name);
        /* google.logging.v2.LogView view = 2; */
        if (message.view)
            exports.LogView.internalBinaryWrite(message.view, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.FieldMask update_mask = 4; */
        if (message.updateMask)
            field_mask_1.FieldMask.internalBinaryWrite(message.updateMask, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.UpdateViewRequest
 */
exports.UpdateViewRequest = new UpdateViewRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetViewRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("google.logging.v2.GetViewRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"], "google.api.resource_reference": { type: "logging.googleapis.com/LogView" } } }
        ]);
    }
    create(value) {
        const message = { name: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.GetViewRequest
 */
exports.GetViewRequest = new GetViewRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteViewRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("google.logging.v2.DeleteViewRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"], "google.api.resource_reference": { type: "logging.googleapis.com/LogView" } } }
        ]);
    }
    create(value) {
        const message = { name: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.DeleteViewRequest
 */
exports.DeleteViewRequest = new DeleteViewRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListSinksRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("google.logging.v2.ListSinksRequest", [
            { no: 1, name: "parent", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"], "google.api.resource_reference": { childType: "logging.googleapis.com/LogSink" } } },
            { no: 2, name: "page_token", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["OPTIONAL"] } },
            { no: 3, name: "page_size", kind: "scalar", T: 5 /*ScalarType.INT32*/, options: { "google.api.field_behavior": ["OPTIONAL"] } }
        ]);
    }
    create(value) {
        const message = { parent: "", pageToken: "", pageSize: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string parent */ 1:
                    message.parent = reader.string();
                    break;
                case /* string page_token */ 2:
                    message.pageToken = reader.string();
                    break;
                case /* int32 page_size */ 3:
                    message.pageSize = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string parent = 1; */
        if (message.parent !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.parent);
        /* string page_token = 2; */
        if (message.pageToken !== "")
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.pageToken);
        /* int32 page_size = 3; */
        if (message.pageSize !== 0)
            writer.tag(3, runtime_1.WireType.Varint).int32(message.pageSize);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.ListSinksRequest
 */
exports.ListSinksRequest = new ListSinksRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListSinksResponse$Type extends runtime_5.MessageType {
    constructor() {
        super("google.logging.v2.ListSinksResponse", [
            { no: 1, name: "sinks", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => exports.LogSink },
            { no: 2, name: "next_page_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = { sinks: [], nextPageToken: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated google.logging.v2.LogSink sinks */ 1:
                    message.sinks.push(exports.LogSink.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string next_page_token */ 2:
                    message.nextPageToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated google.logging.v2.LogSink sinks = 1; */
        for (let i = 0; i < message.sinks.length; i++)
            exports.LogSink.internalBinaryWrite(message.sinks[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* string next_page_token = 2; */
        if (message.nextPageToken !== "")
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.nextPageToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.ListSinksResponse
 */
exports.ListSinksResponse = new ListSinksResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSinkRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("google.logging.v2.GetSinkRequest", [
            { no: 1, name: "sink_name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"], "google.api.resource_reference": { type: "logging.googleapis.com/LogSink" } } }
        ]);
    }
    create(value) {
        const message = { sinkName: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sink_name */ 1:
                    message.sinkName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string sink_name = 1; */
        if (message.sinkName !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.sinkName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.GetSinkRequest
 */
exports.GetSinkRequest = new GetSinkRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateSinkRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("google.logging.v2.CreateSinkRequest", [
            { no: 1, name: "parent", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"], "google.api.resource_reference": { childType: "logging.googleapis.com/LogSink" } } },
            { no: 2, name: "sink", kind: "message", T: () => exports.LogSink, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 3, name: "unique_writer_identity", kind: "scalar", T: 8 /*ScalarType.BOOL*/, options: { "google.api.field_behavior": ["OPTIONAL"] } }
        ]);
    }
    create(value) {
        const message = { parent: "", uniqueWriterIdentity: false };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string parent */ 1:
                    message.parent = reader.string();
                    break;
                case /* google.logging.v2.LogSink sink */ 2:
                    message.sink = exports.LogSink.internalBinaryRead(reader, reader.uint32(), options, message.sink);
                    break;
                case /* bool unique_writer_identity */ 3:
                    message.uniqueWriterIdentity = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string parent = 1; */
        if (message.parent !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.parent);
        /* google.logging.v2.LogSink sink = 2; */
        if (message.sink)
            exports.LogSink.internalBinaryWrite(message.sink, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* bool unique_writer_identity = 3; */
        if (message.uniqueWriterIdentity !== false)
            writer.tag(3, runtime_1.WireType.Varint).bool(message.uniqueWriterIdentity);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.CreateSinkRequest
 */
exports.CreateSinkRequest = new CreateSinkRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateSinkRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("google.logging.v2.UpdateSinkRequest", [
            { no: 1, name: "sink_name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"], "google.api.resource_reference": { type: "logging.googleapis.com/LogSink" } } },
            { no: 2, name: "sink", kind: "message", T: () => exports.LogSink, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 3, name: "unique_writer_identity", kind: "scalar", T: 8 /*ScalarType.BOOL*/, options: { "google.api.field_behavior": ["OPTIONAL"] } },
            { no: 4, name: "update_mask", kind: "message", T: () => field_mask_1.FieldMask, options: { "google.api.field_behavior": ["OPTIONAL"] } }
        ]);
    }
    create(value) {
        const message = { sinkName: "", uniqueWriterIdentity: false };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sink_name */ 1:
                    message.sinkName = reader.string();
                    break;
                case /* google.logging.v2.LogSink sink */ 2:
                    message.sink = exports.LogSink.internalBinaryRead(reader, reader.uint32(), options, message.sink);
                    break;
                case /* bool unique_writer_identity */ 3:
                    message.uniqueWriterIdentity = reader.bool();
                    break;
                case /* google.protobuf.FieldMask update_mask */ 4:
                    message.updateMask = field_mask_1.FieldMask.internalBinaryRead(reader, reader.uint32(), options, message.updateMask);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string sink_name = 1; */
        if (message.sinkName !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.sinkName);
        /* google.logging.v2.LogSink sink = 2; */
        if (message.sink)
            exports.LogSink.internalBinaryWrite(message.sink, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* bool unique_writer_identity = 3; */
        if (message.uniqueWriterIdentity !== false)
            writer.tag(3, runtime_1.WireType.Varint).bool(message.uniqueWriterIdentity);
        /* google.protobuf.FieldMask update_mask = 4; */
        if (message.updateMask)
            field_mask_1.FieldMask.internalBinaryWrite(message.updateMask, writer.tag(4, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.UpdateSinkRequest
 */
exports.UpdateSinkRequest = new UpdateSinkRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteSinkRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("google.logging.v2.DeleteSinkRequest", [
            { no: 1, name: "sink_name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"], "google.api.resource_reference": { type: "logging.googleapis.com/LogSink" } } }
        ]);
    }
    create(value) {
        const message = { sinkName: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sink_name */ 1:
                    message.sinkName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string sink_name = 1; */
        if (message.sinkName !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.sinkName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.DeleteSinkRequest
 */
exports.DeleteSinkRequest = new DeleteSinkRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LogExclusion$Type extends runtime_5.MessageType {
    constructor() {
        super("google.logging.v2.LogExclusion", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 2, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["OPTIONAL"] } },
            { no: 3, name: "filter", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 4, name: "disabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/, options: { "google.api.field_behavior": ["OPTIONAL"] } },
            { no: 5, name: "create_time", kind: "message", T: () => timestamp_1.Timestamp, options: { "google.api.field_behavior": ["OUTPUT_ONLY"] } },
            { no: 6, name: "update_time", kind: "message", T: () => timestamp_1.Timestamp, options: { "google.api.field_behavior": ["OUTPUT_ONLY"] } }
        ], { "google.api.resource": { type: "logging.googleapis.com/LogExclusion", pattern: ["projects/{project}/exclusions/{exclusion}", "organizations/{organization}/exclusions/{exclusion}", "folders/{folder}/exclusions/{exclusion}", "billingAccounts/{billing_account}/exclusions/{exclusion}"] } });
    }
    create(value) {
        const message = { name: "", description: "", filter: "", disabled: false };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string description */ 2:
                    message.description = reader.string();
                    break;
                case /* string filter */ 3:
                    message.filter = reader.string();
                    break;
                case /* bool disabled */ 4:
                    message.disabled = reader.bool();
                    break;
                case /* google.protobuf.Timestamp create_time */ 5:
                    message.createTime = timestamp_1.Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.createTime);
                    break;
                case /* google.protobuf.Timestamp update_time */ 6:
                    message.updateTime = timestamp_1.Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.updateTime);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.name);
        /* string description = 2; */
        if (message.description !== "")
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.description);
        /* string filter = 3; */
        if (message.filter !== "")
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.filter);
        /* bool disabled = 4; */
        if (message.disabled !== false)
            writer.tag(4, runtime_1.WireType.Varint).bool(message.disabled);
        /* google.protobuf.Timestamp create_time = 5; */
        if (message.createTime)
            timestamp_1.Timestamp.internalBinaryWrite(message.createTime, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp update_time = 6; */
        if (message.updateTime)
            timestamp_1.Timestamp.internalBinaryWrite(message.updateTime, writer.tag(6, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.LogExclusion
 */
exports.LogExclusion = new LogExclusion$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListExclusionsRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("google.logging.v2.ListExclusionsRequest", [
            { no: 1, name: "parent", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"], "google.api.resource_reference": { childType: "logging.googleapis.com/LogExclusion" } } },
            { no: 2, name: "page_token", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["OPTIONAL"] } },
            { no: 3, name: "page_size", kind: "scalar", T: 5 /*ScalarType.INT32*/, options: { "google.api.field_behavior": ["OPTIONAL"] } }
        ]);
    }
    create(value) {
        const message = { parent: "", pageToken: "", pageSize: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string parent */ 1:
                    message.parent = reader.string();
                    break;
                case /* string page_token */ 2:
                    message.pageToken = reader.string();
                    break;
                case /* int32 page_size */ 3:
                    message.pageSize = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string parent = 1; */
        if (message.parent !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.parent);
        /* string page_token = 2; */
        if (message.pageToken !== "")
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.pageToken);
        /* int32 page_size = 3; */
        if (message.pageSize !== 0)
            writer.tag(3, runtime_1.WireType.Varint).int32(message.pageSize);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.ListExclusionsRequest
 */
exports.ListExclusionsRequest = new ListExclusionsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListExclusionsResponse$Type extends runtime_5.MessageType {
    constructor() {
        super("google.logging.v2.ListExclusionsResponse", [
            { no: 1, name: "exclusions", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => exports.LogExclusion },
            { no: 2, name: "next_page_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = { exclusions: [], nextPageToken: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated google.logging.v2.LogExclusion exclusions */ 1:
                    message.exclusions.push(exports.LogExclusion.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string next_page_token */ 2:
                    message.nextPageToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated google.logging.v2.LogExclusion exclusions = 1; */
        for (let i = 0; i < message.exclusions.length; i++)
            exports.LogExclusion.internalBinaryWrite(message.exclusions[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* string next_page_token = 2; */
        if (message.nextPageToken !== "")
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.nextPageToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.ListExclusionsResponse
 */
exports.ListExclusionsResponse = new ListExclusionsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetExclusionRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("google.logging.v2.GetExclusionRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"], "google.api.resource_reference": { type: "logging.googleapis.com/LogExclusion" } } }
        ]);
    }
    create(value) {
        const message = { name: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.GetExclusionRequest
 */
exports.GetExclusionRequest = new GetExclusionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateExclusionRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("google.logging.v2.CreateExclusionRequest", [
            { no: 1, name: "parent", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"], "google.api.resource_reference": { childType: "logging.googleapis.com/LogExclusion" } } },
            { no: 2, name: "exclusion", kind: "message", T: () => exports.LogExclusion, options: { "google.api.field_behavior": ["REQUIRED"] } }
        ]);
    }
    create(value) {
        const message = { parent: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string parent */ 1:
                    message.parent = reader.string();
                    break;
                case /* google.logging.v2.LogExclusion exclusion */ 2:
                    message.exclusion = exports.LogExclusion.internalBinaryRead(reader, reader.uint32(), options, message.exclusion);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string parent = 1; */
        if (message.parent !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.parent);
        /* google.logging.v2.LogExclusion exclusion = 2; */
        if (message.exclusion)
            exports.LogExclusion.internalBinaryWrite(message.exclusion, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.CreateExclusionRequest
 */
exports.CreateExclusionRequest = new CreateExclusionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateExclusionRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("google.logging.v2.UpdateExclusionRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"], "google.api.resource_reference": { type: "logging.googleapis.com/LogExclusion" } } },
            { no: 2, name: "exclusion", kind: "message", T: () => exports.LogExclusion, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 3, name: "update_mask", kind: "message", T: () => field_mask_1.FieldMask, options: { "google.api.field_behavior": ["REQUIRED"] } }
        ]);
    }
    create(value) {
        const message = { name: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* google.logging.v2.LogExclusion exclusion */ 2:
                    message.exclusion = exports.LogExclusion.internalBinaryRead(reader, reader.uint32(), options, message.exclusion);
                    break;
                case /* google.protobuf.FieldMask update_mask */ 3:
                    message.updateMask = field_mask_1.FieldMask.internalBinaryRead(reader, reader.uint32(), options, message.updateMask);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.name);
        /* google.logging.v2.LogExclusion exclusion = 2; */
        if (message.exclusion)
            exports.LogExclusion.internalBinaryWrite(message.exclusion, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.FieldMask update_mask = 3; */
        if (message.updateMask)
            field_mask_1.FieldMask.internalBinaryWrite(message.updateMask, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.UpdateExclusionRequest
 */
exports.UpdateExclusionRequest = new UpdateExclusionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteExclusionRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("google.logging.v2.DeleteExclusionRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"], "google.api.resource_reference": { type: "logging.googleapis.com/LogExclusion" } } }
        ]);
    }
    create(value) {
        const message = { name: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.DeleteExclusionRequest
 */
exports.DeleteExclusionRequest = new DeleteExclusionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetCmekSettingsRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("google.logging.v2.GetCmekSettingsRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"], "google.api.resource_reference": { type: "logging.googleapis.com/CmekSettings" } } }
        ]);
    }
    create(value) {
        const message = { name: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.GetCmekSettingsRequest
 */
exports.GetCmekSettingsRequest = new GetCmekSettingsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateCmekSettingsRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("google.logging.v2.UpdateCmekSettingsRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 2, name: "cmek_settings", kind: "message", T: () => exports.CmekSettings, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 3, name: "update_mask", kind: "message", T: () => field_mask_1.FieldMask, options: { "google.api.field_behavior": ["OPTIONAL"] } }
        ]);
    }
    create(value) {
        const message = { name: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* google.logging.v2.CmekSettings cmek_settings */ 2:
                    message.cmekSettings = exports.CmekSettings.internalBinaryRead(reader, reader.uint32(), options, message.cmekSettings);
                    break;
                case /* google.protobuf.FieldMask update_mask */ 3:
                    message.updateMask = field_mask_1.FieldMask.internalBinaryRead(reader, reader.uint32(), options, message.updateMask);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.name);
        /* google.logging.v2.CmekSettings cmek_settings = 2; */
        if (message.cmekSettings)
            exports.CmekSettings.internalBinaryWrite(message.cmekSettings, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.FieldMask update_mask = 3; */
        if (message.updateMask)
            field_mask_1.FieldMask.internalBinaryWrite(message.updateMask, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.UpdateCmekSettingsRequest
 */
exports.UpdateCmekSettingsRequest = new UpdateCmekSettingsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CmekSettings$Type extends runtime_5.MessageType {
    constructor() {
        super("google.logging.v2.CmekSettings", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["OUTPUT_ONLY"] } },
            { no: 2, name: "kms_key_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "service_account_id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["OUTPUT_ONLY"] } }
        ], { "google.api.resource": { type: "logging.googleapis.com/CmekSettings", pattern: ["projects/{project}/cmekSettings", "organizations/{organization}/cmekSettings", "folders/{folder}/cmekSettings", "billingAccounts/{billing_account}/cmekSettings"] } });
    }
    create(value) {
        const message = { name: "", kmsKeyName: "", serviceAccountId: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string kms_key_name */ 2:
                    message.kmsKeyName = reader.string();
                    break;
                case /* string service_account_id */ 3:
                    message.serviceAccountId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.name);
        /* string kms_key_name = 2; */
        if (message.kmsKeyName !== "")
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.kmsKeyName);
        /* string service_account_id = 3; */
        if (message.serviceAccountId !== "")
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.serviceAccountId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.CmekSettings
 */
exports.CmekSettings = new CmekSettings$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSettingsRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("google.logging.v2.GetSettingsRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"], "google.api.resource_reference": { type: "logging.googleapis.com/Settings" } } }
        ]);
    }
    create(value) {
        const message = { name: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.GetSettingsRequest
 */
exports.GetSettingsRequest = new GetSettingsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateSettingsRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("google.logging.v2.UpdateSettingsRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 2, name: "settings", kind: "message", T: () => exports.Settings, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 3, name: "update_mask", kind: "message", T: () => field_mask_1.FieldMask, options: { "google.api.field_behavior": ["OPTIONAL"] } }
        ]);
    }
    create(value) {
        const message = { name: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* google.logging.v2.Settings settings */ 2:
                    message.settings = exports.Settings.internalBinaryRead(reader, reader.uint32(), options, message.settings);
                    break;
                case /* google.protobuf.FieldMask update_mask */ 3:
                    message.updateMask = field_mask_1.FieldMask.internalBinaryRead(reader, reader.uint32(), options, message.updateMask);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.name);
        /* google.logging.v2.Settings settings = 2; */
        if (message.settings)
            exports.Settings.internalBinaryWrite(message.settings, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.FieldMask update_mask = 3; */
        if (message.updateMask)
            field_mask_1.FieldMask.internalBinaryWrite(message.updateMask, writer.tag(3, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.UpdateSettingsRequest
 */
exports.UpdateSettingsRequest = new UpdateSettingsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Settings$Type extends runtime_5.MessageType {
    constructor() {
        super("google.logging.v2.Settings", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["OUTPUT_ONLY"] } },
            { no: 2, name: "kms_key_name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["OPTIONAL"] } },
            { no: 3, name: "kms_service_account_id", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["OUTPUT_ONLY"] } },
            { no: 4, name: "storage_location", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["OPTIONAL"] } },
            { no: 5, name: "disable_default_sink", kind: "scalar", T: 8 /*ScalarType.BOOL*/, options: { "google.api.field_behavior": ["OPTIONAL"] } }
        ], { "google.api.resource": { type: "logging.googleapis.com/Settings", pattern: ["projects/{project}/settings", "organizations/{organization}/settings", "folders/{folder}/settings", "billingAccounts/{billing_account}/settings"] } });
    }
    create(value) {
        const message = { name: "", kmsKeyName: "", kmsServiceAccountId: "", storageLocation: "", disableDefaultSink: false };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string kms_key_name */ 2:
                    message.kmsKeyName = reader.string();
                    break;
                case /* string kms_service_account_id */ 3:
                    message.kmsServiceAccountId = reader.string();
                    break;
                case /* string storage_location */ 4:
                    message.storageLocation = reader.string();
                    break;
                case /* bool disable_default_sink */ 5:
                    message.disableDefaultSink = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.name);
        /* string kms_key_name = 2; */
        if (message.kmsKeyName !== "")
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.kmsKeyName);
        /* string kms_service_account_id = 3; */
        if (message.kmsServiceAccountId !== "")
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.kmsServiceAccountId);
        /* string storage_location = 4; */
        if (message.storageLocation !== "")
            writer.tag(4, runtime_1.WireType.LengthDelimited).string(message.storageLocation);
        /* bool disable_default_sink = 5; */
        if (message.disableDefaultSink !== false)
            writer.tag(5, runtime_1.WireType.Varint).bool(message.disableDefaultSink);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.Settings
 */
exports.Settings = new Settings$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CopyLogEntriesRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("google.logging.v2.CopyLogEntriesRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 3, name: "filter", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["OPTIONAL"] } },
            { no: 4, name: "destination", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"] } }
        ]);
    }
    create(value) {
        const message = { name: "", filter: "", destination: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string filter */ 3:
                    message.filter = reader.string();
                    break;
                case /* string destination */ 4:
                    message.destination = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.name);
        /* string filter = 3; */
        if (message.filter !== "")
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.filter);
        /* string destination = 4; */
        if (message.destination !== "")
            writer.tag(4, runtime_1.WireType.LengthDelimited).string(message.destination);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.CopyLogEntriesRequest
 */
exports.CopyLogEntriesRequest = new CopyLogEntriesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CopyLogEntriesMetadata$Type extends runtime_5.MessageType {
    constructor() {
        super("google.logging.v2.CopyLogEntriesMetadata", [
            { no: 1, name: "start_time", kind: "message", T: () => timestamp_1.Timestamp },
            { no: 2, name: "end_time", kind: "message", T: () => timestamp_1.Timestamp },
            { no: 3, name: "state", kind: "enum", T: () => ["google.logging.v2.OperationState", OperationState, "OPERATION_STATE_"] },
            { no: 4, name: "cancellation_requested", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "request", kind: "message", T: () => exports.CopyLogEntriesRequest },
            { no: 6, name: "progress", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "writer_identity", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = { state: 0, cancellationRequested: false, progress: 0, writerIdentity: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Timestamp start_time */ 1:
                    message.startTime = timestamp_1.Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.startTime);
                    break;
                case /* google.protobuf.Timestamp end_time */ 2:
                    message.endTime = timestamp_1.Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.endTime);
                    break;
                case /* google.logging.v2.OperationState state */ 3:
                    message.state = reader.int32();
                    break;
                case /* bool cancellation_requested */ 4:
                    message.cancellationRequested = reader.bool();
                    break;
                case /* google.logging.v2.CopyLogEntriesRequest request */ 5:
                    message.request = exports.CopyLogEntriesRequest.internalBinaryRead(reader, reader.uint32(), options, message.request);
                    break;
                case /* int32 progress */ 6:
                    message.progress = reader.int32();
                    break;
                case /* string writer_identity */ 7:
                    message.writerIdentity = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* google.protobuf.Timestamp start_time = 1; */
        if (message.startTime)
            timestamp_1.Timestamp.internalBinaryWrite(message.startTime, writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp end_time = 2; */
        if (message.endTime)
            timestamp_1.Timestamp.internalBinaryWrite(message.endTime, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* google.logging.v2.OperationState state = 3; */
        if (message.state !== 0)
            writer.tag(3, runtime_1.WireType.Varint).int32(message.state);
        /* bool cancellation_requested = 4; */
        if (message.cancellationRequested !== false)
            writer.tag(4, runtime_1.WireType.Varint).bool(message.cancellationRequested);
        /* google.logging.v2.CopyLogEntriesRequest request = 5; */
        if (message.request)
            exports.CopyLogEntriesRequest.internalBinaryWrite(message.request, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* int32 progress = 6; */
        if (message.progress !== 0)
            writer.tag(6, runtime_1.WireType.Varint).int32(message.progress);
        /* string writer_identity = 7; */
        if (message.writerIdentity !== "")
            writer.tag(7, runtime_1.WireType.LengthDelimited).string(message.writerIdentity);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.CopyLogEntriesMetadata
 */
exports.CopyLogEntriesMetadata = new CopyLogEntriesMetadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CopyLogEntriesResponse$Type extends runtime_5.MessageType {
    constructor() {
        super("google.logging.v2.CopyLogEntriesResponse", [
            { no: 1, name: "log_entries_copied_count", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value) {
        const message = { logEntriesCopiedCount: 0n };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 log_entries_copied_count */ 1:
                    message.logEntriesCopiedCount = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* int64 log_entries_copied_count = 1; */
        if (message.logEntriesCopiedCount !== 0n)
            writer.tag(1, runtime_1.WireType.Varint).int64(message.logEntriesCopiedCount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.CopyLogEntriesResponse
 */
exports.CopyLogEntriesResponse = new CopyLogEntriesResponse$Type();
/**
 * @generated ServiceType for protobuf service google.logging.v2.ConfigServiceV2
 */
exports.ConfigServiceV2 = new runtime_rpc_1.ServiceType("google.logging.v2.ConfigServiceV2", [
    { name: "ListBuckets", options: { "google.api.http": { get: "/v2/{parent=*/*/locations/*}/buckets", additionalBindings: [{ get: "/v2/{parent=projects/*/locations/*}/buckets" }, { get: "/v2/{parent=organizations/*/locations/*}/buckets" }, { get: "/v2/{parent=folders/*/locations/*}/buckets" }, { get: "/v2/{parent=billingAccounts/*/locations/*}/buckets" }] }, "google.api.method_signature": ["parent"] }, I: exports.ListBucketsRequest, O: exports.ListBucketsResponse },
    { name: "GetBucket", options: { "google.api.http": { get: "/v2/{name=*/*/locations/*/buckets/*}", additionalBindings: [{ get: "/v2/{name=projects/*/locations/*/buckets/*}" }, { get: "/v2/{name=organizations/*/locations/*/buckets/*}" }, { get: "/v2/{name=folders/*/locations/*/buckets/*}" }, { get: "/v2/{name=billingAccounts/*/buckets/*}" }] } }, I: exports.GetBucketRequest, O: exports.LogBucket },
    { name: "CreateBucket", options: { "google.api.http": { post: "/v2/{parent=*/*/locations/*}/buckets", body: "bucket", additionalBindings: [{ post: "/v2/{parent=projects/*/locations/*}/buckets", body: "bucket" }, { post: "/v2/{parent=organizations/*/locations/*}/buckets", body: "bucket" }, { post: "/v2/{parent=folders/*/locations/*}/buckets", body: "bucket" }, { post: "/v2/{parent=billingAccounts/*/locations/*}/buckets", body: "bucket" }] } }, I: exports.CreateBucketRequest, O: exports.LogBucket },
    { name: "UpdateBucket", options: { "google.api.http": { patch: "/v2/{name=*/*/locations/*/buckets/*}", body: "bucket", additionalBindings: [{ patch: "/v2/{name=projects/*/locations/*/buckets/*}", body: "bucket" }, { patch: "/v2/{name=organizations/*/locations/*/buckets/*}", body: "bucket" }, { patch: "/v2/{name=folders/*/locations/*/buckets/*}", body: "bucket" }, { patch: "/v2/{name=billingAccounts/*/locations/*/buckets/*}", body: "bucket" }] } }, I: exports.UpdateBucketRequest, O: exports.LogBucket },
    { name: "DeleteBucket", options: { "google.api.http": { delete: "/v2/{name=*/*/locations/*/buckets/*}", additionalBindings: [{ delete: "/v2/{name=projects/*/locations/*/buckets/*}" }, { delete: "/v2/{name=organizations/*/locations/*/buckets/*}" }, { delete: "/v2/{name=folders/*/locations/*/buckets/*}" }, { delete: "/v2/{name=billingAccounts/*/locations/*/buckets/*}" }] } }, I: exports.DeleteBucketRequest, O: empty_1.Empty },
    { name: "UndeleteBucket", options: { "google.api.http": { post: "/v2/{name=*/*/locations/*/buckets/*}:undelete", body: "*", additionalBindings: [{ post: "/v2/{name=projects/*/locations/*/buckets/*}:undelete", body: "*" }, { post: "/v2/{name=organizations/*/locations/*/buckets/*}:undelete", body: "*" }, { post: "/v2/{name=folders/*/locations/*/buckets/*}:undelete", body: "*" }, { post: "/v2/{name=billingAccounts/*/locations/*/buckets/*}:undelete", body: "*" }] } }, I: exports.UndeleteBucketRequest, O: empty_1.Empty },
    { name: "ListViews", options: { "google.api.http": { get: "/v2/{parent=*/*/locations/*/buckets/*}/views", additionalBindings: [{ get: "/v2/{parent=projects/*/locations/*/buckets/*}/views" }, { get: "/v2/{parent=organizations/*/locations/*/buckets/*}/views" }, { get: "/v2/{parent=folders/*/locations/*/buckets/*}/views" }, { get: "/v2/{parent=billingAccounts/*/locations/*/buckets/*}/views" }] }, "google.api.method_signature": ["parent"] }, I: exports.ListViewsRequest, O: exports.ListViewsResponse },
    { name: "GetView", options: { "google.api.http": { get: "/v2/{name=*/*/locations/*/buckets/*/views/*}", additionalBindings: [{ get: "/v2/{name=projects/*/locations/*/buckets/*/views/*}" }, { get: "/v2/{name=organizations/*/locations/*/buckets/*/views/*}" }, { get: "/v2/{name=folders/*/locations/*/buckets/*/views/*}" }, { get: "/v2/{name=billingAccounts/*/buckets/*/views/*}" }] } }, I: exports.GetViewRequest, O: exports.LogView },
    { name: "CreateView", options: { "google.api.http": { post: "/v2/{parent=*/*/locations/*/buckets/*}/views", body: "view", additionalBindings: [{ post: "/v2/{parent=projects/*/locations/*/buckets/*}/views", body: "view" }, { post: "/v2/{parent=organizations/*/locations/*/buckets/*}/views", body: "view" }, { post: "/v2/{parent=folders/*/locations/*/buckets/*}/views", body: "view" }, { post: "/v2/{parent=billingAccounts/*/locations/*/buckets/*}/views", body: "view" }] } }, I: exports.CreateViewRequest, O: exports.LogView },
    { name: "UpdateView", options: { "google.api.http": { patch: "/v2/{name=*/*/locations/*/buckets/*/views/*}", body: "view", additionalBindings: [{ patch: "/v2/{name=projects/*/locations/*/buckets/*/views/*}", body: "view" }, { patch: "/v2/{name=organizations/*/locations/*/buckets/*/views/*}", body: "view" }, { patch: "/v2/{name=folders/*/locations/*/buckets/*/views/*}", body: "view" }, { patch: "/v2/{name=billingAccounts/*/locations/*/buckets/*/views/*}", body: "view" }] } }, I: exports.UpdateViewRequest, O: exports.LogView },
    { name: "DeleteView", options: { "google.api.http": { delete: "/v2/{name=*/*/locations/*/buckets/*/views/*}", additionalBindings: [{ delete: "/v2/{name=projects/*/locations/*/buckets/*/views/*}" }, { delete: "/v2/{name=organizations/*/locations/*/buckets/*/views/*}" }, { delete: "/v2/{name=folders/*/locations/*/buckets/*/views/*}" }, { delete: "/v2/{name=billingAccounts/*/locations/*/buckets/*/views/*}" }] } }, I: exports.DeleteViewRequest, O: empty_1.Empty },
    { name: "ListSinks", options: { "google.api.http": { get: "/v2/{parent=*/*}/sinks", additionalBindings: [{ get: "/v2/{parent=projects/*}/sinks" }, { get: "/v2/{parent=organizations/*}/sinks" }, { get: "/v2/{parent=folders/*}/sinks" }, { get: "/v2/{parent=billingAccounts/*}/sinks" }] }, "google.api.method_signature": ["parent"] }, I: exports.ListSinksRequest, O: exports.ListSinksResponse },
    { name: "GetSink", options: { "google.api.http": { get: "/v2/{sink_name=*/*/sinks/*}", additionalBindings: [{ get: "/v2/{sink_name=projects/*/sinks/*}" }, { get: "/v2/{sink_name=organizations/*/sinks/*}" }, { get: "/v2/{sink_name=folders/*/sinks/*}" }, { get: "/v2/{sink_name=billingAccounts/*/sinks/*}" }] }, "google.api.method_signature": ["sink_name"] }, I: exports.GetSinkRequest, O: exports.LogSink },
    { name: "CreateSink", options: { "google.api.http": { post: "/v2/{parent=*/*}/sinks", body: "sink", additionalBindings: [{ post: "/v2/{parent=projects/*}/sinks", body: "sink" }, { post: "/v2/{parent=organizations/*}/sinks", body: "sink" }, { post: "/v2/{parent=folders/*}/sinks", body: "sink" }, { post: "/v2/{parent=billingAccounts/*}/sinks", body: "sink" }] }, "google.api.method_signature": ["parent,sink"] }, I: exports.CreateSinkRequest, O: exports.LogSink },
    { name: "UpdateSink", options: { "google.api.http": { put: "/v2/{sink_name=*/*/sinks/*}", body: "sink", additionalBindings: [{ put: "/v2/{sink_name=projects/*/sinks/*}", body: "sink" }, { put: "/v2/{sink_name=organizations/*/sinks/*}", body: "sink" }, { put: "/v2/{sink_name=folders/*/sinks/*}", body: "sink" }, { put: "/v2/{sink_name=billingAccounts/*/sinks/*}", body: "sink" }, { patch: "/v2/{sink_name=projects/*/sinks/*}", body: "sink" }, { patch: "/v2/{sink_name=organizations/*/sinks/*}", body: "sink" }, { patch: "/v2/{sink_name=folders/*/sinks/*}", body: "sink" }, { patch: "/v2/{sink_name=billingAccounts/*/sinks/*}", body: "sink" }] }, "google.api.method_signature": ["sink_name,sink,update_mask", "sink_name,sink"] }, I: exports.UpdateSinkRequest, O: exports.LogSink },
    { name: "DeleteSink", options: { "google.api.http": { delete: "/v2/{sink_name=*/*/sinks/*}", additionalBindings: [{ delete: "/v2/{sink_name=projects/*/sinks/*}" }, { delete: "/v2/{sink_name=organizations/*/sinks/*}" }, { delete: "/v2/{sink_name=folders/*/sinks/*}" }, { delete: "/v2/{sink_name=billingAccounts/*/sinks/*}" }] }, "google.api.method_signature": ["sink_name"] }, I: exports.DeleteSinkRequest, O: empty_1.Empty },
    { name: "ListExclusions", options: { "google.api.http": { get: "/v2/{parent=*/*}/exclusions", additionalBindings: [{ get: "/v2/{parent=projects/*}/exclusions" }, { get: "/v2/{parent=organizations/*}/exclusions" }, { get: "/v2/{parent=folders/*}/exclusions" }, { get: "/v2/{parent=billingAccounts/*}/exclusions" }] }, "google.api.method_signature": ["parent"] }, I: exports.ListExclusionsRequest, O: exports.ListExclusionsResponse },
    { name: "GetExclusion", options: { "google.api.http": { get: "/v2/{name=*/*/exclusions/*}", additionalBindings: [{ get: "/v2/{name=projects/*/exclusions/*}" }, { get: "/v2/{name=organizations/*/exclusions/*}" }, { get: "/v2/{name=folders/*/exclusions/*}" }, { get: "/v2/{name=billingAccounts/*/exclusions/*}" }] }, "google.api.method_signature": ["name"] }, I: exports.GetExclusionRequest, O: exports.LogExclusion },
    { name: "CreateExclusion", options: { "google.api.http": { post: "/v2/{parent=*/*}/exclusions", body: "exclusion", additionalBindings: [{ post: "/v2/{parent=projects/*}/exclusions", body: "exclusion" }, { post: "/v2/{parent=organizations/*}/exclusions", body: "exclusion" }, { post: "/v2/{parent=folders/*}/exclusions", body: "exclusion" }, { post: "/v2/{parent=billingAccounts/*}/exclusions", body: "exclusion" }] }, "google.api.method_signature": ["parent,exclusion"] }, I: exports.CreateExclusionRequest, O: exports.LogExclusion },
    { name: "UpdateExclusion", options: { "google.api.http": { patch: "/v2/{name=*/*/exclusions/*}", body: "exclusion", additionalBindings: [{ patch: "/v2/{name=projects/*/exclusions/*}", body: "exclusion" }, { patch: "/v2/{name=organizations/*/exclusions/*}", body: "exclusion" }, { patch: "/v2/{name=folders/*/exclusions/*}", body: "exclusion" }, { patch: "/v2/{name=billingAccounts/*/exclusions/*}", body: "exclusion" }] }, "google.api.method_signature": ["name,exclusion,update_mask"] }, I: exports.UpdateExclusionRequest, O: exports.LogExclusion },
    { name: "DeleteExclusion", options: { "google.api.http": { delete: "/v2/{name=*/*/exclusions/*}", additionalBindings: [{ delete: "/v2/{name=projects/*/exclusions/*}" }, { delete: "/v2/{name=organizations/*/exclusions/*}" }, { delete: "/v2/{name=folders/*/exclusions/*}" }, { delete: "/v2/{name=billingAccounts/*/exclusions/*}" }] }, "google.api.method_signature": ["name"] }, I: exports.DeleteExclusionRequest, O: empty_1.Empty },
    { name: "GetCmekSettings", options: { "google.api.http": { get: "/v2/{name=*/*}/cmekSettings", additionalBindings: [{ get: "/v2/{name=projects/*}/cmekSettings" }, { get: "/v2/{name=organizations/*}/cmekSettings" }, { get: "/v2/{name=folders/*}/cmekSettings" }, { get: "/v2/{name=billingAccounts/*}/cmekSettings" }] } }, I: exports.GetCmekSettingsRequest, O: exports.CmekSettings },
    { name: "UpdateCmekSettings", options: { "google.api.http": { patch: "/v2/{name=*/*}/cmekSettings", body: "cmek_settings", additionalBindings: [{ patch: "/v2/{name=organizations/*}/cmekSettings", body: "cmek_settings" }] } }, I: exports.UpdateCmekSettingsRequest, O: exports.CmekSettings },
    { name: "GetSettings", options: { "google.api.http": { get: "/v2/{name=*/*}/settings", additionalBindings: [{ get: "/v2/{name=projects/*}/settings" }, { get: "/v2/{name=organizations/*}/settings" }, { get: "/v2/{name=folders/*}/settings" }, { get: "/v2/{name=billingAccounts/*}/settings" }] }, "google.api.method_signature": ["name"] }, I: exports.GetSettingsRequest, O: exports.Settings },
    { name: "UpdateSettings", options: { "google.api.http": { patch: "/v2/{name=*/*}/settings", body: "settings", additionalBindings: [{ patch: "/v2/{name=organizations/*}/settings", body: "settings" }, { patch: "/v2/{name=folders/*}/settings", body: "settings" }] }, "google.api.method_signature": ["settings,update_mask"] }, I: exports.UpdateSettingsRequest, O: exports.Settings },
    { name: "CopyLogEntries", options: { "google.api.http": { post: "/v2/entries:copy", body: "*" }, "google.longrunning.operation_info": { responseType: "CopyLogEntriesResponse", metadataType: "CopyLogEntriesMetadata" } }, I: exports.CopyLogEntriesRequest, O: operations_1.Operation }
], { "google.api.default_host": "logging.googleapis.com", "google.api.oauth_scopes": "https://www.googleapis.com/auth/cloud-platform,https://www.googleapis.com/auth/cloud-platform.read-only,https://www.googleapis.com/auth/logging.admin,https://www.googleapis.com/auth/logging.read" });
//# sourceMappingURL=logging_config.js.map