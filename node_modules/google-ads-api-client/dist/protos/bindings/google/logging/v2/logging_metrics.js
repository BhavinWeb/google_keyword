"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MetricsServiceV2 = exports.DeleteLogMetricRequest = exports.UpdateLogMetricRequest = exports.CreateLogMetricRequest = exports.GetLogMetricRequest = exports.ListLogMetricsResponse = exports.ListLogMetricsRequest = exports.LogMetric = exports.LogMetric_ApiVersion = void 0;
// @generated by protobuf-ts 2.8.1
// @generated from protobuf file "google/logging/v2/logging_metrics.proto" (package "google.logging.v2", syntax proto3)
// tslint:disable
//
// Copyright 2022 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
const empty_1 = require("../../protobuf/empty");
const runtime_rpc_1 = require("@protobuf-ts/runtime-rpc");
const runtime_1 = require("@protobuf-ts/runtime");
const runtime_2 = require("@protobuf-ts/runtime");
const runtime_3 = require("@protobuf-ts/runtime");
const runtime_4 = require("@protobuf-ts/runtime");
const runtime_5 = require("@protobuf-ts/runtime");
const timestamp_1 = require("../../protobuf/timestamp");
const distribution_1 = require("../../api/distribution");
const metric_1 = require("../../api/metric");
/**
 * Logging API version.
 *
 * @generated from protobuf enum google.logging.v2.LogMetric.ApiVersion
 */
var LogMetric_ApiVersion;
(function (LogMetric_ApiVersion) {
    /**
     * Logging API v2.
     *
     * @generated from protobuf enum value: V2 = 0;
     */
    LogMetric_ApiVersion[LogMetric_ApiVersion["V2"] = 0] = "V2";
    /**
     * Logging API v1.
     *
     * @generated from protobuf enum value: V1 = 1;
     */
    LogMetric_ApiVersion[LogMetric_ApiVersion["V1"] = 1] = "V1";
})(LogMetric_ApiVersion = exports.LogMetric_ApiVersion || (exports.LogMetric_ApiVersion = {}));
// @generated message type with reflection information, may provide speed optimized methods
class LogMetric$Type extends runtime_5.MessageType {
    constructor() {
        super("google.logging.v2.LogMetric", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 2, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["OPTIONAL"] } },
            { no: 3, name: "filter", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"] } },
            { no: 12, name: "disabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/, options: { "google.api.field_behavior": ["OPTIONAL"] } },
            { no: 5, name: "metric_descriptor", kind: "message", T: () => metric_1.MetricDescriptor, options: { "google.api.field_behavior": ["OPTIONAL"] } },
            { no: 6, name: "value_extractor", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["OPTIONAL"] } },
            { no: 7, name: "label_extractors", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ }, options: { "google.api.field_behavior": ["OPTIONAL"] } },
            { no: 8, name: "bucket_options", kind: "message", T: () => distribution_1.Distribution_BucketOptions, options: { "google.api.field_behavior": ["OPTIONAL"] } },
            { no: 9, name: "create_time", kind: "message", T: () => timestamp_1.Timestamp, options: { "google.api.field_behavior": ["OUTPUT_ONLY"] } },
            { no: 10, name: "update_time", kind: "message", T: () => timestamp_1.Timestamp, options: { "google.api.field_behavior": ["OUTPUT_ONLY"] } },
            { no: 4, name: "version", kind: "enum", T: () => ["google.logging.v2.LogMetric.ApiVersion", LogMetric_ApiVersion] }
        ], { "google.api.resource": { type: "logging.googleapis.com/LogMetric", pattern: ["projects/{project}/metrics/{metric}"] } });
    }
    create(value) {
        const message = { name: "", description: "", filter: "", disabled: false, valueExtractor: "", labelExtractors: {}, version: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string description */ 2:
                    message.description = reader.string();
                    break;
                case /* string filter */ 3:
                    message.filter = reader.string();
                    break;
                case /* bool disabled */ 12:
                    message.disabled = reader.bool();
                    break;
                case /* google.api.MetricDescriptor metric_descriptor */ 5:
                    message.metricDescriptor = metric_1.MetricDescriptor.internalBinaryRead(reader, reader.uint32(), options, message.metricDescriptor);
                    break;
                case /* string value_extractor */ 6:
                    message.valueExtractor = reader.string();
                    break;
                case /* map<string, string> label_extractors */ 7:
                    this.binaryReadMap7(message.labelExtractors, reader, options);
                    break;
                case /* google.api.Distribution.BucketOptions bucket_options */ 8:
                    message.bucketOptions = distribution_1.Distribution_BucketOptions.internalBinaryRead(reader, reader.uint32(), options, message.bucketOptions);
                    break;
                case /* google.protobuf.Timestamp create_time */ 9:
                    message.createTime = timestamp_1.Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.createTime);
                    break;
                case /* google.protobuf.Timestamp update_time */ 10:
                    message.updateTime = timestamp_1.Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.updateTime);
                    break;
                case /* google.logging.v2.LogMetric.ApiVersion version = 4 [deprecated = true];*/ 4:
                    message.version = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    binaryReadMap7(map, reader, options) {
        let len = reader.uint32(), end = reader.pos + len, key, val;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field google.logging.v2.LogMetric.label_extractors");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message, writer, options) {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.name);
        /* string description = 2; */
        if (message.description !== "")
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.description);
        /* string filter = 3; */
        if (message.filter !== "")
            writer.tag(3, runtime_1.WireType.LengthDelimited).string(message.filter);
        /* bool disabled = 12; */
        if (message.disabled !== false)
            writer.tag(12, runtime_1.WireType.Varint).bool(message.disabled);
        /* google.api.MetricDescriptor metric_descriptor = 5; */
        if (message.metricDescriptor)
            metric_1.MetricDescriptor.internalBinaryWrite(message.metricDescriptor, writer.tag(5, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* string value_extractor = 6; */
        if (message.valueExtractor !== "")
            writer.tag(6, runtime_1.WireType.LengthDelimited).string(message.valueExtractor);
        /* map<string, string> label_extractors = 7; */
        for (let k of Object.keys(message.labelExtractors))
            writer.tag(7, runtime_1.WireType.LengthDelimited).fork().tag(1, runtime_1.WireType.LengthDelimited).string(k).tag(2, runtime_1.WireType.LengthDelimited).string(message.labelExtractors[k]).join();
        /* google.api.Distribution.BucketOptions bucket_options = 8; */
        if (message.bucketOptions)
            distribution_1.Distribution_BucketOptions.internalBinaryWrite(message.bucketOptions, writer.tag(8, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp create_time = 9; */
        if (message.createTime)
            timestamp_1.Timestamp.internalBinaryWrite(message.createTime, writer.tag(9, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp update_time = 10; */
        if (message.updateTime)
            timestamp_1.Timestamp.internalBinaryWrite(message.updateTime, writer.tag(10, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* google.logging.v2.LogMetric.ApiVersion version = 4 [deprecated = true]; */
        if (message.version !== 0)
            writer.tag(4, runtime_1.WireType.Varint).int32(message.version);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.LogMetric
 */
exports.LogMetric = new LogMetric$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListLogMetricsRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("google.logging.v2.ListLogMetricsRequest", [
            { no: 1, name: "parent", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"], "google.api.resource_reference": { type: "cloudresourcemanager.googleapis.com/Project" } } },
            { no: 2, name: "page_token", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["OPTIONAL"] } },
            { no: 3, name: "page_size", kind: "scalar", T: 5 /*ScalarType.INT32*/, options: { "google.api.field_behavior": ["OPTIONAL"] } }
        ]);
    }
    create(value) {
        const message = { parent: "", pageToken: "", pageSize: 0 };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string parent */ 1:
                    message.parent = reader.string();
                    break;
                case /* string page_token */ 2:
                    message.pageToken = reader.string();
                    break;
                case /* int32 page_size */ 3:
                    message.pageSize = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string parent = 1; */
        if (message.parent !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.parent);
        /* string page_token = 2; */
        if (message.pageToken !== "")
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.pageToken);
        /* int32 page_size = 3; */
        if (message.pageSize !== 0)
            writer.tag(3, runtime_1.WireType.Varint).int32(message.pageSize);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.ListLogMetricsRequest
 */
exports.ListLogMetricsRequest = new ListLogMetricsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListLogMetricsResponse$Type extends runtime_5.MessageType {
    constructor() {
        super("google.logging.v2.ListLogMetricsResponse", [
            { no: 1, name: "metrics", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => exports.LogMetric },
            { no: 2, name: "next_page_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value) {
        const message = { metrics: [], nextPageToken: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated google.logging.v2.LogMetric metrics */ 1:
                    message.metrics.push(exports.LogMetric.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string next_page_token */ 2:
                    message.nextPageToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated google.logging.v2.LogMetric metrics = 1; */
        for (let i = 0; i < message.metrics.length; i++)
            exports.LogMetric.internalBinaryWrite(message.metrics[i], writer.tag(1, runtime_1.WireType.LengthDelimited).fork(), options).join();
        /* string next_page_token = 2; */
        if (message.nextPageToken !== "")
            writer.tag(2, runtime_1.WireType.LengthDelimited).string(message.nextPageToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.ListLogMetricsResponse
 */
exports.ListLogMetricsResponse = new ListLogMetricsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetLogMetricRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("google.logging.v2.GetLogMetricRequest", [
            { no: 1, name: "metric_name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"], "google.api.resource_reference": { type: "logging.googleapis.com/LogMetric" } } }
        ]);
    }
    create(value) {
        const message = { metricName: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string metric_name */ 1:
                    message.metricName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string metric_name = 1; */
        if (message.metricName !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.metricName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.GetLogMetricRequest
 */
exports.GetLogMetricRequest = new GetLogMetricRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateLogMetricRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("google.logging.v2.CreateLogMetricRequest", [
            { no: 1, name: "parent", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"], "google.api.resource_reference": { childType: "logging.googleapis.com/LogMetric" } } },
            { no: 2, name: "metric", kind: "message", T: () => exports.LogMetric, options: { "google.api.field_behavior": ["REQUIRED"] } }
        ]);
    }
    create(value) {
        const message = { parent: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string parent */ 1:
                    message.parent = reader.string();
                    break;
                case /* google.logging.v2.LogMetric metric */ 2:
                    message.metric = exports.LogMetric.internalBinaryRead(reader, reader.uint32(), options, message.metric);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string parent = 1; */
        if (message.parent !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.parent);
        /* google.logging.v2.LogMetric metric = 2; */
        if (message.metric)
            exports.LogMetric.internalBinaryWrite(message.metric, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.CreateLogMetricRequest
 */
exports.CreateLogMetricRequest = new CreateLogMetricRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateLogMetricRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("google.logging.v2.UpdateLogMetricRequest", [
            { no: 1, name: "metric_name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"], "google.api.resource_reference": { type: "logging.googleapis.com/LogMetric" } } },
            { no: 2, name: "metric", kind: "message", T: () => exports.LogMetric, options: { "google.api.field_behavior": ["REQUIRED"] } }
        ]);
    }
    create(value) {
        const message = { metricName: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string metric_name */ 1:
                    message.metricName = reader.string();
                    break;
                case /* google.logging.v2.LogMetric metric */ 2:
                    message.metric = exports.LogMetric.internalBinaryRead(reader, reader.uint32(), options, message.metric);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string metric_name = 1; */
        if (message.metricName !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.metricName);
        /* google.logging.v2.LogMetric metric = 2; */
        if (message.metric)
            exports.LogMetric.internalBinaryWrite(message.metric, writer.tag(2, runtime_1.WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.UpdateLogMetricRequest
 */
exports.UpdateLogMetricRequest = new UpdateLogMetricRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteLogMetricRequest$Type extends runtime_5.MessageType {
    constructor() {
        super("google.logging.v2.DeleteLogMetricRequest", [
            { no: 1, name: "metric_name", kind: "scalar", T: 9 /*ScalarType.STRING*/, options: { "google.api.field_behavior": ["REQUIRED"], "google.api.resource_reference": { type: "logging.googleapis.com/LogMetric" } } }
        ]);
    }
    create(value) {
        const message = { metricName: "" };
        globalThis.Object.defineProperty(message, runtime_4.MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            (0, runtime_3.reflectionMergePartial)(this, message, value);
        return message;
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string metric_name */ 1:
                    message.metricName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? runtime_2.UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message, writer, options) {
        /* string metric_name = 1; */
        if (message.metricName !== "")
            writer.tag(1, runtime_1.WireType.LengthDelimited).string(message.metricName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? runtime_2.UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.logging.v2.DeleteLogMetricRequest
 */
exports.DeleteLogMetricRequest = new DeleteLogMetricRequest$Type();
/**
 * @generated ServiceType for protobuf service google.logging.v2.MetricsServiceV2
 */
exports.MetricsServiceV2 = new runtime_rpc_1.ServiceType("google.logging.v2.MetricsServiceV2", [
    { name: "ListLogMetrics", options: { "google.api.http": { get: "/v2/{parent=projects/*}/metrics" }, "google.api.method_signature": ["parent"] }, I: exports.ListLogMetricsRequest, O: exports.ListLogMetricsResponse },
    { name: "GetLogMetric", options: { "google.api.http": { get: "/v2/{metric_name=projects/*/metrics/*}" }, "google.api.method_signature": ["metric_name"] }, I: exports.GetLogMetricRequest, O: exports.LogMetric },
    { name: "CreateLogMetric", options: { "google.api.http": { post: "/v2/{parent=projects/*}/metrics", body: "metric" }, "google.api.method_signature": ["parent,metric"] }, I: exports.CreateLogMetricRequest, O: exports.LogMetric },
    { name: "UpdateLogMetric", options: { "google.api.http": { put: "/v2/{metric_name=projects/*/metrics/*}", body: "metric" }, "google.api.method_signature": ["metric_name,metric"] }, I: exports.UpdateLogMetricRequest, O: exports.LogMetric },
    { name: "DeleteLogMetric", options: { "google.api.http": { delete: "/v2/{metric_name=projects/*/metrics/*}" }, "google.api.method_signature": ["metric_name"] }, I: exports.DeleteLogMetricRequest, O: empty_1.Empty }
], { "google.api.default_host": "logging.googleapis.com", "google.api.oauth_scopes": "https://www.googleapis.com/auth/cloud-platform,https://www.googleapis.com/auth/cloud-platform.read-only,https://www.googleapis.com/auth/logging.admin,https://www.googleapis.com/auth/logging.read,https://www.googleapis.com/auth/logging.write" });
//# sourceMappingURL=logging_metrics.js.map