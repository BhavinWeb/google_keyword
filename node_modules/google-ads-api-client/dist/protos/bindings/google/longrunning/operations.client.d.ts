import type { RpcTransport } from "@protobuf-ts/runtime-rpc";
import type { ServiceInfo } from "@protobuf-ts/runtime-rpc";
import type { WaitOperationRequest } from "./operations";
import type { CancelOperationRequest } from "./operations";
import type { Empty } from "../protobuf/empty";
import type { DeleteOperationRequest } from "./operations";
import type { Operation } from "./operations";
import type { GetOperationRequest } from "./operations";
import type { ListOperationsResponse } from "./operations";
import type { ListOperationsRequest } from "./operations";
import type { UnaryCall } from "@protobuf-ts/runtime-rpc";
import type { RpcOptions } from "@protobuf-ts/runtime-rpc";
/**
 * Manages long-running operations with an API service.
 *
 * When an API method normally takes long time to complete, it can be designed
 * to return [Operation][google.longrunning.Operation] to the client, and the client can use this
 * interface to receive the real response asynchronously by polling the
 * operation resource, or pass the operation resource to another API (such as
 * Google Cloud Pub/Sub API) to receive the response.  Any API service that
 * returns long-running operations should implement the `Operations` interface
 * so developers can have a consistent client experience.
 *
 * @generated from protobuf service google.longrunning.Operations
 */
export interface IOperationsClient {
    /**
     * Lists operations that match the specified filter in the request. If the
     * server doesn't support this method, it returns `UNIMPLEMENTED`.
     *
     * NOTE: the `name` binding allows API services to override the binding
     * to use different resource name schemes, such as `users/*\/operations`. To
     * override the binding, API services can add a binding such as
     * `"/v1/{name=users/*}/operations"` to their service configuration.
     * For backwards compatibility, the default name includes the operations
     * collection id, however overriding users must ensure the name binding
     * is the parent resource, without the operations collection id.
     *
     * @generated from protobuf rpc: ListOperations(google.longrunning.ListOperationsRequest) returns (google.longrunning.ListOperationsResponse);
     */
    listOperations(input: ListOperationsRequest, options?: RpcOptions): UnaryCall<ListOperationsRequest, ListOperationsResponse>;
    /**
     * Gets the latest state of a long-running operation.  Clients can use this
     * method to poll the operation result at intervals as recommended by the API
     * service.
     *
     * @generated from protobuf rpc: GetOperation(google.longrunning.GetOperationRequest) returns (google.longrunning.Operation);
     */
    getOperation(input: GetOperationRequest, options?: RpcOptions): UnaryCall<GetOperationRequest, Operation>;
    /**
     * Deletes a long-running operation. This method indicates that the client is
     * no longer interested in the operation result. It does not cancel the
     * operation. If the server doesn't support this method, it returns
     * `google.rpc.Code.UNIMPLEMENTED`.
     *
     * @generated from protobuf rpc: DeleteOperation(google.longrunning.DeleteOperationRequest) returns (google.protobuf.Empty);
     */
    deleteOperation(input: DeleteOperationRequest, options?: RpcOptions): UnaryCall<DeleteOperationRequest, Empty>;
    /**
     * Starts asynchronous cancellation on a long-running operation.  The server
     * makes a best effort to cancel the operation, but success is not
     * guaranteed.  If the server doesn't support this method, it returns
     * `google.rpc.Code.UNIMPLEMENTED`.  Clients can use
     * [Operations.GetOperation][google.longrunning.Operations.GetOperation] or
     * other methods to check whether the cancellation succeeded or whether the
     * operation completed despite cancellation. On successful cancellation,
     * the operation is not deleted; instead, it becomes an operation with
     * an [Operation.error][google.longrunning.Operation.error] value with a [google.rpc.Status.code][google.rpc.Status.code] of 1,
     * corresponding to `Code.CANCELLED`.
     *
     * @generated from protobuf rpc: CancelOperation(google.longrunning.CancelOperationRequest) returns (google.protobuf.Empty);
     */
    cancelOperation(input: CancelOperationRequest, options?: RpcOptions): UnaryCall<CancelOperationRequest, Empty>;
    /**
     * Waits until the specified long-running operation is done or reaches at most
     * a specified timeout, returning the latest state.  If the operation is
     * already done, the latest state is immediately returned.  If the timeout
     * specified is greater than the default HTTP/RPC timeout, the HTTP/RPC
     * timeout is used.  If the server does not support this method, it returns
     * `google.rpc.Code.UNIMPLEMENTED`.
     * Note that this method is on a best-effort basis.  It may return the latest
     * state before the specified timeout (including immediately), meaning even an
     * immediate response is no guarantee that the operation is done.
     *
     * @generated from protobuf rpc: WaitOperation(google.longrunning.WaitOperationRequest) returns (google.longrunning.Operation);
     */
    waitOperation(input: WaitOperationRequest, options?: RpcOptions): UnaryCall<WaitOperationRequest, Operation>;
}
/**
 * Manages long-running operations with an API service.
 *
 * When an API method normally takes long time to complete, it can be designed
 * to return [Operation][google.longrunning.Operation] to the client, and the client can use this
 * interface to receive the real response asynchronously by polling the
 * operation resource, or pass the operation resource to another API (such as
 * Google Cloud Pub/Sub API) to receive the response.  Any API service that
 * returns long-running operations should implement the `Operations` interface
 * so developers can have a consistent client experience.
 *
 * @generated from protobuf service google.longrunning.Operations
 */
export declare class OperationsClient implements IOperationsClient, ServiceInfo {
    private readonly _transport;
    typeName: string;
    methods: import("@protobuf-ts/runtime-rpc").MethodInfo<any, any>[];
    options: {
        [extensionName: string]: import("@protobuf-ts/runtime").JsonValue;
    };
    constructor(_transport: RpcTransport);
    /**
     * Lists operations that match the specified filter in the request. If the
     * server doesn't support this method, it returns `UNIMPLEMENTED`.
     *
     * NOTE: the `name` binding allows API services to override the binding
     * to use different resource name schemes, such as `users/*\/operations`. To
     * override the binding, API services can add a binding such as
     * `"/v1/{name=users/*}/operations"` to their service configuration.
     * For backwards compatibility, the default name includes the operations
     * collection id, however overriding users must ensure the name binding
     * is the parent resource, without the operations collection id.
     *
     * @generated from protobuf rpc: ListOperations(google.longrunning.ListOperationsRequest) returns (google.longrunning.ListOperationsResponse);
     */
    listOperations(input: ListOperationsRequest, options?: RpcOptions): UnaryCall<ListOperationsRequest, ListOperationsResponse>;
    /**
     * Gets the latest state of a long-running operation.  Clients can use this
     * method to poll the operation result at intervals as recommended by the API
     * service.
     *
     * @generated from protobuf rpc: GetOperation(google.longrunning.GetOperationRequest) returns (google.longrunning.Operation);
     */
    getOperation(input: GetOperationRequest, options?: RpcOptions): UnaryCall<GetOperationRequest, Operation>;
    /**
     * Deletes a long-running operation. This method indicates that the client is
     * no longer interested in the operation result. It does not cancel the
     * operation. If the server doesn't support this method, it returns
     * `google.rpc.Code.UNIMPLEMENTED`.
     *
     * @generated from protobuf rpc: DeleteOperation(google.longrunning.DeleteOperationRequest) returns (google.protobuf.Empty);
     */
    deleteOperation(input: DeleteOperationRequest, options?: RpcOptions): UnaryCall<DeleteOperationRequest, Empty>;
    /**
     * Starts asynchronous cancellation on a long-running operation.  The server
     * makes a best effort to cancel the operation, but success is not
     * guaranteed.  If the server doesn't support this method, it returns
     * `google.rpc.Code.UNIMPLEMENTED`.  Clients can use
     * [Operations.GetOperation][google.longrunning.Operations.GetOperation] or
     * other methods to check whether the cancellation succeeded or whether the
     * operation completed despite cancellation. On successful cancellation,
     * the operation is not deleted; instead, it becomes an operation with
     * an [Operation.error][google.longrunning.Operation.error] value with a [google.rpc.Status.code][google.rpc.Status.code] of 1,
     * corresponding to `Code.CANCELLED`.
     *
     * @generated from protobuf rpc: CancelOperation(google.longrunning.CancelOperationRequest) returns (google.protobuf.Empty);
     */
    cancelOperation(input: CancelOperationRequest, options?: RpcOptions): UnaryCall<CancelOperationRequest, Empty>;
    /**
     * Waits until the specified long-running operation is done or reaches at most
     * a specified timeout, returning the latest state.  If the operation is
     * already done, the latest state is immediately returned.  If the timeout
     * specified is greater than the default HTTP/RPC timeout, the HTTP/RPC
     * timeout is used.  If the server does not support this method, it returns
     * `google.rpc.Code.UNIMPLEMENTED`.
     * Note that this method is on a best-effort basis.  It may return the latest
     * state before the specified timeout (including immediately), meaning even an
     * immediate response is no guarantee that the operation is done.
     *
     * @generated from protobuf rpc: WaitOperation(google.longrunning.WaitOperationRequest) returns (google.longrunning.Operation);
     */
    waitOperation(input: WaitOperationRequest, options?: RpcOptions): UnaryCall<WaitOperationRequest, Operation>;
}
