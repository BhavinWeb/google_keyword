import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Timestamp } from "../../../protobuf/timestamp";
import { Duration } from "../../../protobuf/duration";
import { NullValue } from "../../../protobuf/struct";
/**
 * An expression together with source information as returned by the parser.
 *
 * @generated from protobuf message google.api.expr.v1alpha1.ParsedExpr
 */
export interface ParsedExpr {
    /**
     * The parsed expression.
     *
     * @generated from protobuf field: google.api.expr.v1alpha1.Expr expr = 2;
     */
    expr?: Expr;
    /**
     * The source info derived from input that generated the parsed `expr`.
     *
     * @generated from protobuf field: google.api.expr.v1alpha1.SourceInfo source_info = 3;
     */
    sourceInfo?: SourceInfo;
}
/**
 * An abstract representation of a common expression.
 *
 * Expressions are abstractly represented as a collection of identifiers,
 * select statements, function calls, literals, and comprehensions. All
 * operators with the exception of the '.' operator are modelled as function
 * calls. This makes it easy to represent new operators into the existing AST.
 *
 * All references within expressions must resolve to a [Decl][google.api.expr.v1alpha1.Decl] provided at
 * type-check for an expression to be valid. A reference may either be a bare
 * identifier `name` or a qualified identifier `google.api.name`. References
 * may either refer to a value or a function declaration.
 *
 * For example, the expression `google.api.name.startsWith('expr')` references
 * the declaration `google.api.name` within a [Expr.Select][google.api.expr.v1alpha1.Expr.Select] expression, and
 * the function declaration `startsWith`.
 *
 * @generated from protobuf message google.api.expr.v1alpha1.Expr
 */
export interface Expr {
    /**
     * Required. An id assigned to this node by the parser which is unique in a
     * given expression tree. This is used to associate type information and other
     * attributes to a node in the parse tree.
     *
     * @generated from protobuf field: int64 id = 2;
     */
    id: bigint;
    /**
     * @generated from protobuf oneof: expr_kind
     */
    exprKind: {
        oneofKind: "constExpr";
        /**
         * A literal expression.
         *
         * @generated from protobuf field: google.api.expr.v1alpha1.Constant const_expr = 3;
         */
        constExpr: Constant;
    } | {
        oneofKind: "identExpr";
        /**
         * An identifier expression.
         *
         * @generated from protobuf field: google.api.expr.v1alpha1.Expr.Ident ident_expr = 4;
         */
        identExpr: Expr_Ident;
    } | {
        oneofKind: "selectExpr";
        /**
         * A field selection expression, e.g. `request.auth`.
         *
         * @generated from protobuf field: google.api.expr.v1alpha1.Expr.Select select_expr = 5;
         */
        selectExpr: Expr_Select;
    } | {
        oneofKind: "callExpr";
        /**
         * A call expression, including calls to predefined functions and operators.
         *
         * @generated from protobuf field: google.api.expr.v1alpha1.Expr.Call call_expr = 6;
         */
        callExpr: Expr_Call;
    } | {
        oneofKind: "listExpr";
        /**
         * A list creation expression.
         *
         * @generated from protobuf field: google.api.expr.v1alpha1.Expr.CreateList list_expr = 7;
         */
        listExpr: Expr_CreateList;
    } | {
        oneofKind: "structExpr";
        /**
         * A map or message creation expression.
         *
         * @generated from protobuf field: google.api.expr.v1alpha1.Expr.CreateStruct struct_expr = 8;
         */
        structExpr: Expr_CreateStruct;
    } | {
        oneofKind: "comprehensionExpr";
        /**
         * A comprehension expression.
         *
         * @generated from protobuf field: google.api.expr.v1alpha1.Expr.Comprehension comprehension_expr = 9;
         */
        comprehensionExpr: Expr_Comprehension;
    } | {
        oneofKind: undefined;
    };
}
/**
 * An identifier expression. e.g. `request`.
 *
 * @generated from protobuf message google.api.expr.v1alpha1.Expr.Ident
 */
export interface Expr_Ident {
    /**
     * Required. Holds a single, unqualified identifier, possibly preceded by a
     * '.'.
     *
     * Qualified names are represented by the [Expr.Select][google.api.expr.v1alpha1.Expr.Select] expression.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
}
/**
 * A field selection expression. e.g. `request.auth`.
 *
 * @generated from protobuf message google.api.expr.v1alpha1.Expr.Select
 */
export interface Expr_Select {
    /**
     * Required. The target of the selection expression.
     *
     * For example, in the select expression `request.auth`, the `request`
     * portion of the expression is the `operand`.
     *
     * @generated from protobuf field: google.api.expr.v1alpha1.Expr operand = 1;
     */
    operand?: Expr;
    /**
     * Required. The name of the field to select.
     *
     * For example, in the select expression `request.auth`, the `auth` portion
     * of the expression would be the `field`.
     *
     * @generated from protobuf field: string field = 2;
     */
    field: string;
    /**
     * Whether the select is to be interpreted as a field presence test.
     *
     * This results from the macro `has(request.auth)`.
     *
     * @generated from protobuf field: bool test_only = 3;
     */
    testOnly: boolean;
}
/**
 * A call expression, including calls to predefined functions and operators.
 *
 * For example, `value == 10`, `size(map_value)`.
 *
 * @generated from protobuf message google.api.expr.v1alpha1.Expr.Call
 */
export interface Expr_Call {
    /**
     * The target of an method call-style expression. For example, `x` in
     * `x.f()`.
     *
     * @generated from protobuf field: google.api.expr.v1alpha1.Expr target = 1;
     */
    target?: Expr;
    /**
     * Required. The name of the function or method being called.
     *
     * @generated from protobuf field: string function = 2;
     */
    function: string;
    /**
     * The arguments.
     *
     * @generated from protobuf field: repeated google.api.expr.v1alpha1.Expr args = 3;
     */
    args: Expr[];
}
/**
 * A list creation expression.
 *
 * Lists may either be homogenous, e.g. `[1, 2, 3]`, or heterogeneous, e.g.
 * `dyn([1, 'hello', 2.0])`
 *
 * @generated from protobuf message google.api.expr.v1alpha1.Expr.CreateList
 */
export interface Expr_CreateList {
    /**
     * The elements part of the list.
     *
     * @generated from protobuf field: repeated google.api.expr.v1alpha1.Expr elements = 1;
     */
    elements: Expr[];
}
/**
 * A map or message creation expression.
 *
 * Maps are constructed as `{'key_name': 'value'}`. Message construction is
 * similar, but prefixed with a type name and composed of field ids:
 * `types.MyType{field_id: 'value'}`.
 *
 * @generated from protobuf message google.api.expr.v1alpha1.Expr.CreateStruct
 */
export interface Expr_CreateStruct {
    /**
     * The type name of the message to be created, empty when creating map
     * literals.
     *
     * @generated from protobuf field: string message_name = 1;
     */
    messageName: string;
    /**
     * The entries in the creation expression.
     *
     * @generated from protobuf field: repeated google.api.expr.v1alpha1.Expr.CreateStruct.Entry entries = 2;
     */
    entries: Expr_CreateStruct_Entry[];
}
/**
 * Represents an entry.
 *
 * @generated from protobuf message google.api.expr.v1alpha1.Expr.CreateStruct.Entry
 */
export interface Expr_CreateStruct_Entry {
    /**
     * Required. An id assigned to this node by the parser which is unique
     * in a given expression tree. This is used to associate type
     * information and other attributes to the node.
     *
     * @generated from protobuf field: int64 id = 1;
     */
    id: bigint;
    /**
     * @generated from protobuf oneof: key_kind
     */
    keyKind: {
        oneofKind: "fieldKey";
        /**
         * The field key for a message creator statement.
         *
         * @generated from protobuf field: string field_key = 2;
         */
        fieldKey: string;
    } | {
        oneofKind: "mapKey";
        /**
         * The key expression for a map creation statement.
         *
         * @generated from protobuf field: google.api.expr.v1alpha1.Expr map_key = 3;
         */
        mapKey: Expr;
    } | {
        oneofKind: undefined;
    };
    /**
     * Required. The value assigned to the key.
     *
     * If the optional_entry field is true, the expression must resolve to an
     * optional-typed value. If the optional value is present, the key will be
     * set; however, if the optional value is absent, the key will be unset.
     *
     * @generated from protobuf field: google.api.expr.v1alpha1.Expr value = 4;
     */
    value?: Expr;
    /**
     * Whether the key-value pair is optional.
     *
     * @generated from protobuf field: bool optional_entry = 5;
     */
    optionalEntry: boolean;
}
/**
 * A comprehension expression applied to a list or map.
 *
 * Comprehensions are not part of the core syntax, but enabled with macros.
 * A macro matches a specific call signature within a parsed AST and replaces
 * the call with an alternate AST block. Macro expansion happens at parse
 * time.
 *
 * The following macros are supported within CEL:
 *
 * Aggregate type macros may be applied to all elements in a list or all keys
 * in a map:
 *
 * *  `all`, `exists`, `exists_one` -  test a predicate expression against
 *    the inputs and return `true` if the predicate is satisfied for all,
 *    any, or only one value `list.all(x, x < 10)`.
 * *  `filter` - test a predicate expression against the inputs and return
 *    the subset of elements which satisfy the predicate:
 *    `payments.filter(p, p > 1000)`.
 * *  `map` - apply an expression to all elements in the input and return the
 *    output aggregate type: `[1, 2, 3].map(i, i * i)`.
 *
 * The `has(m.x)` macro tests whether the property `x` is present in struct
 * `m`. The semantics of this macro depend on the type of `m`. For proto2
 * messages `has(m.x)` is defined as 'defined, but not set`. For proto3, the
 * macro tests whether the property is set to its default. For map and struct
 * types, the macro tests whether the property `x` is defined on `m`.
 *
 * @generated from protobuf message google.api.expr.v1alpha1.Expr.Comprehension
 */
export interface Expr_Comprehension {
    /**
     * The name of the iteration variable.
     *
     * @generated from protobuf field: string iter_var = 1;
     */
    iterVar: string;
    /**
     * The range over which var iterates.
     *
     * @generated from protobuf field: google.api.expr.v1alpha1.Expr iter_range = 2;
     */
    iterRange?: Expr;
    /**
     * The name of the variable used for accumulation of the result.
     *
     * @generated from protobuf field: string accu_var = 3;
     */
    accuVar: string;
    /**
     * The initial value of the accumulator.
     *
     * @generated from protobuf field: google.api.expr.v1alpha1.Expr accu_init = 4;
     */
    accuInit?: Expr;
    /**
     * An expression which can contain iter_var and accu_var.
     *
     * Returns false when the result has been computed and may be used as
     * a hint to short-circuit the remainder of the comprehension.
     *
     * @generated from protobuf field: google.api.expr.v1alpha1.Expr loop_condition = 5;
     */
    loopCondition?: Expr;
    /**
     * An expression which can contain iter_var and accu_var.
     *
     * Computes the next value of accu_var.
     *
     * @generated from protobuf field: google.api.expr.v1alpha1.Expr loop_step = 6;
     */
    loopStep?: Expr;
    /**
     * An expression which can contain accu_var.
     *
     * Computes the result.
     *
     * @generated from protobuf field: google.api.expr.v1alpha1.Expr result = 7;
     */
    result?: Expr;
}
/**
 * Represents a primitive literal.
 *
 * Named 'Constant' here for backwards compatibility.
 *
 * This is similar as the primitives supported in the well-known type
 * `google.protobuf.Value`, but richer so it can represent CEL's full range of
 * primitives.
 *
 * Lists and structs are not included as constants as these aggregate types may
 * contain [Expr][google.api.expr.v1alpha1.Expr] elements which require evaluation and are thus not constant.
 *
 * Examples of literals include: `"hello"`, `b'bytes'`, `1u`, `4.2`, `-2`,
 * `true`, `null`.
 *
 * @generated from protobuf message google.api.expr.v1alpha1.Constant
 */
export interface Constant {
    /**
     * @generated from protobuf oneof: constant_kind
     */
    constantKind: {
        oneofKind: "nullValue";
        /**
         * null value.
         *
         * @generated from protobuf field: google.protobuf.NullValue null_value = 1;
         */
        nullValue: NullValue;
    } | {
        oneofKind: "boolValue";
        /**
         * boolean value.
         *
         * @generated from protobuf field: bool bool_value = 2;
         */
        boolValue: boolean;
    } | {
        oneofKind: "int64Value";
        /**
         * int64 value.
         *
         * @generated from protobuf field: int64 int64_value = 3;
         */
        int64Value: bigint;
    } | {
        oneofKind: "uint64Value";
        /**
         * uint64 value.
         *
         * @generated from protobuf field: uint64 uint64_value = 4;
         */
        uint64Value: bigint;
    } | {
        oneofKind: "doubleValue";
        /**
         * double value.
         *
         * @generated from protobuf field: double double_value = 5;
         */
        doubleValue: number;
    } | {
        oneofKind: "stringValue";
        /**
         * string value.
         *
         * @generated from protobuf field: string string_value = 6;
         */
        stringValue: string;
    } | {
        oneofKind: "bytesValue";
        /**
         * bytes value.
         *
         * @generated from protobuf field: bytes bytes_value = 7;
         */
        bytesValue: Uint8Array;
    } | {
        oneofKind: "durationValue";
        /**
         * protobuf.Duration value.
         *
         * Deprecated: duration is no longer considered a builtin cel type.
         *
         * @deprecated
         * @generated from protobuf field: google.protobuf.Duration duration_value = 8 [deprecated = true];
         */
        durationValue: Duration;
    } | {
        oneofKind: "timestampValue";
        /**
         * protobuf.Timestamp value.
         *
         * Deprecated: timestamp is no longer considered a builtin cel type.
         *
         * @deprecated
         * @generated from protobuf field: google.protobuf.Timestamp timestamp_value = 9 [deprecated = true];
         */
        timestampValue: Timestamp;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Source information collected at parse time.
 *
 * @generated from protobuf message google.api.expr.v1alpha1.SourceInfo
 */
export interface SourceInfo {
    /**
     * The syntax version of the source, e.g. `cel1`.
     *
     * @generated from protobuf field: string syntax_version = 1;
     */
    syntaxVersion: string;
    /**
     * The location name. All position information attached to an expression is
     * relative to this location.
     *
     * The location could be a file, UI element, or similar. For example,
     * `acme/app/AnvilPolicy.cel`.
     *
     * @generated from protobuf field: string location = 2;
     */
    location: string;
    /**
     * Monotonically increasing list of code point offsets where newlines
     * `\n` appear.
     *
     * The line number of a given position is the index `i` where for a given
     * `id` the `line_offsets[i] < id_positions[id] < line_offsets[i+1]`. The
     * column may be derivd from `id_positions[id] - line_offsets[i]`.
     *
     * @generated from protobuf field: repeated int32 line_offsets = 3;
     */
    lineOffsets: number[];
    /**
     * A map from the parse node id (e.g. `Expr.id`) to the code point offset
     * within the source.
     *
     * @generated from protobuf field: map<int64, int32> positions = 4;
     */
    positions: {
        [key: string]: number;
    };
    /**
     * A map from the parse node id where a macro replacement was made to the
     * call `Expr` that resulted in a macro expansion.
     *
     * For example, `has(value.field)` is a function call that is replaced by a
     * `test_only` field selection in the AST. Likewise, the call
     * `list.exists(e, e > 10)` translates to a comprehension expression. The key
     * in the map corresponds to the expression id of the expanded macro, and the
     * value is the call `Expr` that was replaced.
     *
     * @generated from protobuf field: map<int64, google.api.expr.v1alpha1.Expr> macro_calls = 5;
     */
    macroCalls: {
        [key: string]: Expr;
    };
}
/**
 * A specific position in source.
 *
 * @generated from protobuf message google.api.expr.v1alpha1.SourcePosition
 */
export interface SourcePosition {
    /**
     * The soucre location name (e.g. file name).
     *
     * @generated from protobuf field: string location = 1;
     */
    location: string;
    /**
     * The UTF-8 code unit offset.
     *
     * @generated from protobuf field: int32 offset = 2;
     */
    offset: number;
    /**
     * The 1-based index of the starting line in the source text
     * where the issue occurs, or 0 if unknown.
     *
     * @generated from protobuf field: int32 line = 3;
     */
    line: number;
    /**
     * The 0-based index of the starting position within the line of source text
     * where the issue occurs.  Only meaningful if line is nonzero.
     *
     * @generated from protobuf field: int32 column = 4;
     */
    column: number;
}
declare class ParsedExpr$Type extends MessageType<ParsedExpr> {
    constructor();
    create(value?: PartialMessage<ParsedExpr>): ParsedExpr;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ParsedExpr): ParsedExpr;
    internalBinaryWrite(message: ParsedExpr, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message google.api.expr.v1alpha1.ParsedExpr
 */
export declare const ParsedExpr: ParsedExpr$Type;
declare class Expr$Type extends MessageType<Expr> {
    constructor();
    create(value?: PartialMessage<Expr>): Expr;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Expr): Expr;
    internalBinaryWrite(message: Expr, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message google.api.expr.v1alpha1.Expr
 */
export declare const Expr: Expr$Type;
declare class Expr_Ident$Type extends MessageType<Expr_Ident> {
    constructor();
    create(value?: PartialMessage<Expr_Ident>): Expr_Ident;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Expr_Ident): Expr_Ident;
    internalBinaryWrite(message: Expr_Ident, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message google.api.expr.v1alpha1.Expr.Ident
 */
export declare const Expr_Ident: Expr_Ident$Type;
declare class Expr_Select$Type extends MessageType<Expr_Select> {
    constructor();
    create(value?: PartialMessage<Expr_Select>): Expr_Select;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Expr_Select): Expr_Select;
    internalBinaryWrite(message: Expr_Select, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message google.api.expr.v1alpha1.Expr.Select
 */
export declare const Expr_Select: Expr_Select$Type;
declare class Expr_Call$Type extends MessageType<Expr_Call> {
    constructor();
    create(value?: PartialMessage<Expr_Call>): Expr_Call;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Expr_Call): Expr_Call;
    internalBinaryWrite(message: Expr_Call, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message google.api.expr.v1alpha1.Expr.Call
 */
export declare const Expr_Call: Expr_Call$Type;
declare class Expr_CreateList$Type extends MessageType<Expr_CreateList> {
    constructor();
    create(value?: PartialMessage<Expr_CreateList>): Expr_CreateList;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Expr_CreateList): Expr_CreateList;
    internalBinaryWrite(message: Expr_CreateList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message google.api.expr.v1alpha1.Expr.CreateList
 */
export declare const Expr_CreateList: Expr_CreateList$Type;
declare class Expr_CreateStruct$Type extends MessageType<Expr_CreateStruct> {
    constructor();
    create(value?: PartialMessage<Expr_CreateStruct>): Expr_CreateStruct;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Expr_CreateStruct): Expr_CreateStruct;
    internalBinaryWrite(message: Expr_CreateStruct, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message google.api.expr.v1alpha1.Expr.CreateStruct
 */
export declare const Expr_CreateStruct: Expr_CreateStruct$Type;
declare class Expr_CreateStruct_Entry$Type extends MessageType<Expr_CreateStruct_Entry> {
    constructor();
    create(value?: PartialMessage<Expr_CreateStruct_Entry>): Expr_CreateStruct_Entry;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Expr_CreateStruct_Entry): Expr_CreateStruct_Entry;
    internalBinaryWrite(message: Expr_CreateStruct_Entry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message google.api.expr.v1alpha1.Expr.CreateStruct.Entry
 */
export declare const Expr_CreateStruct_Entry: Expr_CreateStruct_Entry$Type;
declare class Expr_Comprehension$Type extends MessageType<Expr_Comprehension> {
    constructor();
    create(value?: PartialMessage<Expr_Comprehension>): Expr_Comprehension;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Expr_Comprehension): Expr_Comprehension;
    internalBinaryWrite(message: Expr_Comprehension, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message google.api.expr.v1alpha1.Expr.Comprehension
 */
export declare const Expr_Comprehension: Expr_Comprehension$Type;
declare class Constant$Type extends MessageType<Constant> {
    constructor();
    create(value?: PartialMessage<Constant>): Constant;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Constant): Constant;
    internalBinaryWrite(message: Constant, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message google.api.expr.v1alpha1.Constant
 */
export declare const Constant: Constant$Type;
declare class SourceInfo$Type extends MessageType<SourceInfo> {
    constructor();
    create(value?: PartialMessage<SourceInfo>): SourceInfo;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SourceInfo): SourceInfo;
    private binaryReadMap4;
    private binaryReadMap5;
    internalBinaryWrite(message: SourceInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message google.api.expr.v1alpha1.SourceInfo
 */
export declare const SourceInfo: SourceInfo$Type;
declare class SourcePosition$Type extends MessageType<SourcePosition> {
    constructor();
    create(value?: PartialMessage<SourcePosition>): SourcePosition;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SourcePosition): SourcePosition;
    internalBinaryWrite(message: SourcePosition, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message google.api.expr.v1alpha1.SourcePosition
 */
export declare const SourcePosition: SourcePosition$Type;
export {};
