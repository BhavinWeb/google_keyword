import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Status } from "../../../rpc/status";
import { MetricValueSet } from "./metric_value";
/**
 * Request message for the AllocateQuota method.
 *
 * @generated from protobuf message google.api.servicecontrol.v1.AllocateQuotaRequest
 */
export interface AllocateQuotaRequest {
    /**
     * Name of the service as specified in the service configuration. For example,
     * `"pubsub.googleapis.com"`.
     *
     * See [google.api.Service][google.api.Service] for the definition of a service name.
     *
     * @generated from protobuf field: string service_name = 1;
     */
    serviceName: string;
    /**
     * Operation that describes the quota allocation.
     *
     * @generated from protobuf field: google.api.servicecontrol.v1.QuotaOperation allocate_operation = 2;
     */
    allocateOperation?: QuotaOperation;
    /**
     * Specifies which version of service configuration should be used to process
     * the request. If unspecified or no matching version can be found, the latest
     * one will be used.
     *
     * @generated from protobuf field: string service_config_id = 4;
     */
    serviceConfigId: string;
}
/**
 * Represents information regarding a quota operation.
 *
 * @generated from protobuf message google.api.servicecontrol.v1.QuotaOperation
 */
export interface QuotaOperation {
    /**
     * Identity of the operation. This is expected to be unique within the scope
     * of the service that generated the operation, and guarantees idempotency in
     * case of retries.
     *
     * In order to ensure best performance and latency in the Quota backends,
     * operation_ids are optimally associated with time, so that related
     * operations can be accessed fast in storage. For this reason, the
     * recommended token for services that intend to operate at a high QPS is
     * Unix time in nanos + UUID
     *
     * @generated from protobuf field: string operation_id = 1;
     */
    operationId: string;
    /**
     * Fully qualified name of the API method for which this quota operation is
     * requested. This name is used for matching quota rules or metric rules and
     * billing status rules defined in service configuration.
     *
     * This field should not be set if any of the following is true:
     * (1) the quota operation is performed on non-API resources.
     * (2) quota_metrics is set because the caller is doing quota override.
     *
     *
     * Example of an RPC method name:
     *     google.example.library.v1.LibraryService.CreateShelf
     *
     * @generated from protobuf field: string method_name = 2;
     */
    methodName: string;
    /**
     * Identity of the consumer for whom this quota operation is being performed.
     *
     * This can be in one of the following formats:
     *   project:<project_id>,
     *   project_number:<project_number>,
     *   api_key:<api_key>.
     *
     * @generated from protobuf field: string consumer_id = 3;
     */
    consumerId: string;
    /**
     * Labels describing the operation.
     *
     * @generated from protobuf field: map<string, string> labels = 4;
     */
    labels: {
        [key: string]: string;
    };
    /**
     * Represents information about this operation. Each MetricValueSet
     * corresponds to a metric defined in the service configuration.
     * The data type used in the MetricValueSet must agree with
     * the data type specified in the metric definition.
     *
     * Within a single operation, it is not allowed to have more than one
     * MetricValue instances that have the same metric names and identical
     * label value combinations. If a request has such duplicated MetricValue
     * instances, the entire request is rejected with
     * an invalid argument error.
     *
     * This field is mutually exclusive with method_name.
     *
     * @generated from protobuf field: repeated google.api.servicecontrol.v1.MetricValueSet quota_metrics = 5;
     */
    quotaMetrics: MetricValueSet[];
    /**
     * Quota mode for this operation.
     *
     * @generated from protobuf field: google.api.servicecontrol.v1.QuotaOperation.QuotaMode quota_mode = 6;
     */
    quotaMode: QuotaOperation_QuotaMode;
}
/**
 * Supported quota modes.
 *
 * @generated from protobuf enum google.api.servicecontrol.v1.QuotaOperation.QuotaMode
 */
export declare enum QuotaOperation_QuotaMode {
    /**
     * Guard against implicit default. Must not be used.
     *
     * @generated from protobuf enum value: UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * For AllocateQuota request, allocates quota for the amount specified in
     * the service configuration or specified using the quota metrics. If the
     * amount is higher than the available quota, allocation error will be
     * returned and no quota will be allocated.
     * If multiple quotas are part of the request, and one fails, none of the
     * quotas are allocated or released.
     *
     * @generated from protobuf enum value: NORMAL = 1;
     */
    NORMAL = 1,
    /**
     * The operation allocates quota for the amount specified in the service
     * configuration or specified using the quota metrics. If the amount is
     * higher than the available quota, request does not fail but all available
     * quota will be allocated.
     * For rate quota, BEST_EFFORT will continue to deduct from other groups
     * even if one does not have enough quota. For allocation, it will find the
     * minimum available amount across all groups and deduct that amount from
     * all the affected groups.
     *
     * @generated from protobuf enum value: BEST_EFFORT = 2;
     */
    BEST_EFFORT = 2,
    /**
     * For AllocateQuota request, only checks if there is enough quota
     * available and does not change the available quota. No lock is placed on
     * the available quota either.
     *
     * @generated from protobuf enum value: CHECK_ONLY = 3;
     */
    CHECK_ONLY = 3,
    /**
     * Unimplemented. When used in AllocateQuotaRequest, this returns the
     * effective quota limit(s) in the response, and no quota check will be
     * performed. Not supported for other requests, and even for
     * AllocateQuotaRequest, this is currently supported only for allowlisted
     * services.
     *
     * @generated from protobuf enum value: QUERY_ONLY = 4;
     */
    QUERY_ONLY = 4,
    /**
     * The operation allocates quota for the amount specified in the service
     * configuration or specified using the quota metrics. If the requested
     * amount is higher than the available quota, request does not fail and
     * remaining quota would become negative (going over the limit).
     * Not supported for Rate Quota.
     *
     * @generated from protobuf enum value: ADJUST_ONLY = 5;
     */
    ADJUST_ONLY = 5
}
/**
 * Response message for the AllocateQuota method.
 *
 * @generated from protobuf message google.api.servicecontrol.v1.AllocateQuotaResponse
 */
export interface AllocateQuotaResponse {
    /**
     * The same operation_id value used in the AllocateQuotaRequest. Used for
     * logging and diagnostics purposes.
     *
     * @generated from protobuf field: string operation_id = 1;
     */
    operationId: string;
    /**
     * Indicates the decision of the allocate.
     *
     * @generated from protobuf field: repeated google.api.servicecontrol.v1.QuotaError allocate_errors = 2;
     */
    allocateErrors: QuotaError[];
    /**
     * Quota metrics to indicate the result of allocation. Depending on the
     * request, one or more of the following metrics will be included:
     *
     * 1. Per quota group or per quota metric incremental usage will be specified
     * using the following delta metric :
     *   "serviceruntime.googleapis.com/api/consumer/quota_used_count"
     *
     * 2. The quota limit reached condition will be specified using the following
     * boolean metric :
     *   "serviceruntime.googleapis.com/quota/exceeded"
     *
     * @generated from protobuf field: repeated google.api.servicecontrol.v1.MetricValueSet quota_metrics = 3;
     */
    quotaMetrics: MetricValueSet[];
    /**
     * ID of the actual config used to process the request.
     *
     * @generated from protobuf field: string service_config_id = 4;
     */
    serviceConfigId: string;
}
/**
 * Represents error information for [QuotaOperation][google.api.servicecontrol.v1.QuotaOperation].
 *
 * @generated from protobuf message google.api.servicecontrol.v1.QuotaError
 */
export interface QuotaError {
    /**
     * Error code.
     *
     * @generated from protobuf field: google.api.servicecontrol.v1.QuotaError.Code code = 1;
     */
    code: QuotaError_Code;
    /**
     * Subject to whom this error applies. See the specific enum for more details
     * on this field. For example, "clientip:<ip address of client>" or
     * "project:<Google developer project id>".
     *
     * @generated from protobuf field: string subject = 2;
     */
    subject: string;
    /**
     * Free-form text that provides details on the cause of the error.
     *
     * @generated from protobuf field: string description = 3;
     */
    description: string;
    /**
     * Contains additional information about the quota error.
     * If available, `status.code` will be non zero.
     *
     * @generated from protobuf field: google.rpc.Status status = 4;
     */
    status?: Status;
}
/**
 * Error codes related to project config validations are deprecated since the
 * quota controller methods do not perform these validations. Instead services
 * have to call the Check method, without quota_properties field, to perform
 * these validations before calling the quota controller methods. These
 * methods check only for project deletion to be wipe out compliant.
 *
 * @generated from protobuf enum google.api.servicecontrol.v1.QuotaError.Code
 */
export declare enum QuotaError_Code {
    /**
     * This is never used.
     *
     * @generated from protobuf enum value: UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * Quota allocation failed.
     * Same as [google.rpc.Code.RESOURCE_EXHAUSTED][google.rpc.Code.RESOURCE_EXHAUSTED].
     *
     * @generated from protobuf enum value: RESOURCE_EXHAUSTED = 8;
     */
    RESOURCE_EXHAUSTED = 8,
    /**
     * Consumer cannot access the service because the service requires active
     * billing.
     *
     * @generated from protobuf enum value: BILLING_NOT_ACTIVE = 107;
     */
    BILLING_NOT_ACTIVE = 107,
    /**
     * Consumer's project has been marked as deleted (soft deletion).
     *
     * @generated from protobuf enum value: PROJECT_DELETED = 108;
     */
    PROJECT_DELETED = 108,
    /**
     * Specified API key is invalid.
     *
     * @generated from protobuf enum value: API_KEY_INVALID = 105;
     */
    API_KEY_INVALID = 105,
    /**
     * Specified API Key has expired.
     *
     * @generated from protobuf enum value: API_KEY_EXPIRED = 112;
     */
    API_KEY_EXPIRED = 112
}
declare class AllocateQuotaRequest$Type extends MessageType<AllocateQuotaRequest> {
    constructor();
    create(value?: PartialMessage<AllocateQuotaRequest>): AllocateQuotaRequest;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AllocateQuotaRequest): AllocateQuotaRequest;
    internalBinaryWrite(message: AllocateQuotaRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message google.api.servicecontrol.v1.AllocateQuotaRequest
 */
export declare const AllocateQuotaRequest: AllocateQuotaRequest$Type;
declare class QuotaOperation$Type extends MessageType<QuotaOperation> {
    constructor();
    create(value?: PartialMessage<QuotaOperation>): QuotaOperation;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QuotaOperation): QuotaOperation;
    private binaryReadMap4;
    internalBinaryWrite(message: QuotaOperation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message google.api.servicecontrol.v1.QuotaOperation
 */
export declare const QuotaOperation: QuotaOperation$Type;
declare class AllocateQuotaResponse$Type extends MessageType<AllocateQuotaResponse> {
    constructor();
    create(value?: PartialMessage<AllocateQuotaResponse>): AllocateQuotaResponse;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AllocateQuotaResponse): AllocateQuotaResponse;
    internalBinaryWrite(message: AllocateQuotaResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message google.api.servicecontrol.v1.AllocateQuotaResponse
 */
export declare const AllocateQuotaResponse: AllocateQuotaResponse$Type;
declare class QuotaError$Type extends MessageType<QuotaError> {
    constructor();
    create(value?: PartialMessage<QuotaError>): QuotaError;
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: QuotaError): QuotaError;
    internalBinaryWrite(message: QuotaError, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter;
}
/**
 * @generated MessageType for protobuf message google.api.servicecontrol.v1.QuotaError
 */
export declare const QuotaError: QuotaError$Type;
/**
 * @generated ServiceType for protobuf service google.api.servicecontrol.v1.QuotaController
 */
export declare const QuotaController: ServiceType;
export {};
