"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ServiceManagerClient = void 0;
const servicemanager_1 = require("./servicemanager");
const runtime_rpc_1 = require("@protobuf-ts/runtime-rpc");
/**
 * [Google Service Management
 * API](https://cloud.google.com/service-infrastructure/docs/overview)
 *
 * @generated from protobuf service google.api.servicemanagement.v1.ServiceManager
 */
class ServiceManagerClient {
    constructor(_transport) {
        this._transport = _transport;
        this.typeName = servicemanager_1.ServiceManager.typeName;
        this.methods = servicemanager_1.ServiceManager.methods;
        this.options = servicemanager_1.ServiceManager.options;
    }
    /**
     * Lists managed services.
     *
     * Returns all public services. For authenticated users, also returns all
     * services the calling user has "servicemanagement.services.get" permission
     * for.
     *
     * @generated from protobuf rpc: ListServices(google.api.servicemanagement.v1.ListServicesRequest) returns (google.api.servicemanagement.v1.ListServicesResponse);
     */
    listServices(input, options) {
        const method = this.methods[0], opt = this._transport.mergeOptions(options);
        return (0, runtime_rpc_1.stackIntercept)("unary", this._transport, method, opt, input);
    }
    /**
     * Gets a managed service. Authentication is required unless the service is
     * public.
     *
     * @generated from protobuf rpc: GetService(google.api.servicemanagement.v1.GetServiceRequest) returns (google.api.servicemanagement.v1.ManagedService);
     */
    getService(input, options) {
        const method = this.methods[1], opt = this._transport.mergeOptions(options);
        return (0, runtime_rpc_1.stackIntercept)("unary", this._transport, method, opt, input);
    }
    /**
     * Creates a new managed service.
     *
     * A managed service is immutable, and is subject to mandatory 30-day
     * data retention. You cannot move a service or recreate it within 30 days
     * after deletion.
     *
     * One producer project can own no more than 500 services. For security and
     * reliability purposes, a production service should be hosted in a
     * dedicated producer project.
     *
     * Operation<response: ManagedService>
     *
     * @generated from protobuf rpc: CreateService(google.api.servicemanagement.v1.CreateServiceRequest) returns (google.longrunning.Operation);
     */
    createService(input, options) {
        const method = this.methods[2], opt = this._transport.mergeOptions(options);
        return (0, runtime_rpc_1.stackIntercept)("unary", this._transport, method, opt, input);
    }
    /**
     * Deletes a managed service. This method will change the service to the
     * `Soft-Delete` state for 30 days. Within this period, service producers may
     * call
     * [UndeleteService][google.api.servicemanagement.v1.ServiceManager.UndeleteService]
     * to restore the service. After 30 days, the service will be permanently
     * deleted.
     *
     * Operation<response: google.protobuf.Empty>
     *
     * @generated from protobuf rpc: DeleteService(google.api.servicemanagement.v1.DeleteServiceRequest) returns (google.longrunning.Operation);
     */
    deleteService(input, options) {
        const method = this.methods[3], opt = this._transport.mergeOptions(options);
        return (0, runtime_rpc_1.stackIntercept)("unary", this._transport, method, opt, input);
    }
    /**
     * Revives a previously deleted managed service. The method restores the
     * service using the configuration at the time the service was deleted.
     * The target service must exist and must have been deleted within the
     * last 30 days.
     *
     * Operation<response: UndeleteServiceResponse>
     *
     * @generated from protobuf rpc: UndeleteService(google.api.servicemanagement.v1.UndeleteServiceRequest) returns (google.longrunning.Operation);
     */
    undeleteService(input, options) {
        const method = this.methods[4], opt = this._transport.mergeOptions(options);
        return (0, runtime_rpc_1.stackIntercept)("unary", this._transport, method, opt, input);
    }
    /**
     * Lists the history of the service configuration for a managed service,
     * from the newest to the oldest.
     *
     * @generated from protobuf rpc: ListServiceConfigs(google.api.servicemanagement.v1.ListServiceConfigsRequest) returns (google.api.servicemanagement.v1.ListServiceConfigsResponse);
     */
    listServiceConfigs(input, options) {
        const method = this.methods[5], opt = this._transport.mergeOptions(options);
        return (0, runtime_rpc_1.stackIntercept)("unary", this._transport, method, opt, input);
    }
    /**
     * Gets a service configuration (version) for a managed service.
     *
     * @generated from protobuf rpc: GetServiceConfig(google.api.servicemanagement.v1.GetServiceConfigRequest) returns (google.api.Service);
     */
    getServiceConfig(input, options) {
        const method = this.methods[6], opt = this._transport.mergeOptions(options);
        return (0, runtime_rpc_1.stackIntercept)("unary", this._transport, method, opt, input);
    }
    /**
     * Creates a new service configuration (version) for a managed service.
     * This method only stores the service configuration. To roll out the service
     * configuration to backend systems please call
     * [CreateServiceRollout][google.api.servicemanagement.v1.ServiceManager.CreateServiceRollout].
     *
     * Only the 100 most recent service configurations and ones referenced by
     * existing rollouts are kept for each service. The rest will be deleted
     * eventually.
     *
     * @generated from protobuf rpc: CreateServiceConfig(google.api.servicemanagement.v1.CreateServiceConfigRequest) returns (google.api.Service);
     */
    createServiceConfig(input, options) {
        const method = this.methods[7], opt = this._transport.mergeOptions(options);
        return (0, runtime_rpc_1.stackIntercept)("unary", this._transport, method, opt, input);
    }
    /**
     * Creates a new service configuration (version) for a managed service based
     * on
     * user-supplied configuration source files (for example: OpenAPI
     * Specification). This method stores the source configurations as well as the
     * generated service configuration. To rollout the service configuration to
     * other services,
     * please call
     * [CreateServiceRollout][google.api.servicemanagement.v1.ServiceManager.CreateServiceRollout].
     *
     * Only the 100 most recent configuration sources and ones referenced by
     * existing service configurtions are kept for each service. The rest will be
     * deleted eventually.
     *
     * Operation<response: SubmitConfigSourceResponse>
     *
     * @generated from protobuf rpc: SubmitConfigSource(google.api.servicemanagement.v1.SubmitConfigSourceRequest) returns (google.longrunning.Operation);
     */
    submitConfigSource(input, options) {
        const method = this.methods[8], opt = this._transport.mergeOptions(options);
        return (0, runtime_rpc_1.stackIntercept)("unary", this._transport, method, opt, input);
    }
    /**
     * Lists the history of the service configuration rollouts for a managed
     * service, from the newest to the oldest.
     *
     * @generated from protobuf rpc: ListServiceRollouts(google.api.servicemanagement.v1.ListServiceRolloutsRequest) returns (google.api.servicemanagement.v1.ListServiceRolloutsResponse);
     */
    listServiceRollouts(input, options) {
        const method = this.methods[9], opt = this._transport.mergeOptions(options);
        return (0, runtime_rpc_1.stackIntercept)("unary", this._transport, method, opt, input);
    }
    /**
     * Gets a service configuration
     * [rollout][google.api.servicemanagement.v1.Rollout].
     *
     * @generated from protobuf rpc: GetServiceRollout(google.api.servicemanagement.v1.GetServiceRolloutRequest) returns (google.api.servicemanagement.v1.Rollout);
     */
    getServiceRollout(input, options) {
        const method = this.methods[10], opt = this._transport.mergeOptions(options);
        return (0, runtime_rpc_1.stackIntercept)("unary", this._transport, method, opt, input);
    }
    /**
     * Creates a new service configuration rollout. Based on rollout, the
     * Google Service Management will roll out the service configurations to
     * different backend services. For example, the logging configuration will be
     * pushed to Google Cloud Logging.
     *
     * Please note that any previous pending and running Rollouts and associated
     * Operations will be automatically cancelled so that the latest Rollout will
     * not be blocked by previous Rollouts.
     *
     * Only the 100 most recent (in any state) and the last 10 successful (if not
     * already part of the set of 100 most recent) rollouts are kept for each
     * service. The rest will be deleted eventually.
     *
     * Operation<response: Rollout>
     *
     * @generated from protobuf rpc: CreateServiceRollout(google.api.servicemanagement.v1.CreateServiceRolloutRequest) returns (google.longrunning.Operation);
     */
    createServiceRollout(input, options) {
        const method = this.methods[11], opt = this._transport.mergeOptions(options);
        return (0, runtime_rpc_1.stackIntercept)("unary", this._transport, method, opt, input);
    }
    /**
     * Generates and returns a report (errors, warnings and changes from
     * existing configurations) associated with
     * GenerateConfigReportRequest.new_value
     *
     * If GenerateConfigReportRequest.old_value is specified,
     * GenerateConfigReportRequest will contain a single ChangeReport based on the
     * comparison between GenerateConfigReportRequest.new_value and
     * GenerateConfigReportRequest.old_value.
     * If GenerateConfigReportRequest.old_value is not specified, this method
     * will compare GenerateConfigReportRequest.new_value with the last pushed
     * service configuration.
     *
     * @generated from protobuf rpc: GenerateConfigReport(google.api.servicemanagement.v1.GenerateConfigReportRequest) returns (google.api.servicemanagement.v1.GenerateConfigReportResponse);
     */
    generateConfigReport(input, options) {
        const method = this.methods[12], opt = this._transport.mergeOptions(options);
        return (0, runtime_rpc_1.stackIntercept)("unary", this._transport, method, opt, input);
    }
}
exports.ServiceManagerClient = ServiceManagerClient;
//# sourceMappingURL=servicemanager.client.js.map